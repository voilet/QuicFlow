# 分布式定时任务系统产品需求文档 (PRD)

| 文档版本 | V1.2.0 |
|---------|--------|
| 创建日期 | 2025-01-09 |
| 产品经理 | [苦咖啡] |
| 项目代号 | Quartz-Flow |
| 文档状态 | 评审中 |

---

## 1. 文档概述

### 1.1 文档目的
本文档旨在明确「分布式定时任务系统」的产品需求，定义功能范围、业务流程、技术约束和验收标准，为研发团队提供清晰的开发指引。

### 1.2 背景与问题
当前系统（quic-flow）已具备完善的 QUIC 通信能力、命令下发机制和主机管理功能，但在定时任务调度方面存在以下痛点：

| 痛点 | 描述 | 影响 |
|-----|------|-----|
| 缺乏统一调度 | 各客户端独立维护定时任务，无法集中管理 | 运维成本高，任务执行时间不一致 |
| 无动态配置能力 | 任务变更需要重启客户端或手动配置 | 业务响应慢，影响敏捷性 |
| 缺少分组隔离 | 无法按业务/环境区分任务执行范围 | 资源争抢，多环境混用风险 |
| 执行状态不可见 | 任务执行结果分散在各个客户端 | 故障定位困难，SLA 无法保障 |

### 1.3 目标用户
| 用户角色 | 典型场景 | 核心诉求 |
|---------|---------|---------|
| **运维工程师** | 日常巡检、日志清理、数据备份 | 任务配置简单、执行状态可监控、失败可告警 |
| **SRE工程师** | 故障自愈、扩缩容、健康检查 | 任务高可用、故障转移、执行追踪 |
| **开发人员** | 定时数据同步、报表生成、缓存预热 | 支持 Cron 表达式、任务可重试、日志可查询 |
| **系统管理员** | 系统更新、配置下发、资源清理 | 分组管理、批量操作、权限控制 |

### 1.4 产品愿景
构建一个轻量级、高性能、可观测的分布式定时任务调度系统，无缝集成 quic-flow 现有的 QUIC 通信能力，实现：

> **"一处配置，处处执行；实时可控，全程可溯"**

---

## 2. 核心概念定义

### 2.1 架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                         Web 管理控制台                            │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐        │
│  │ 任务管理   │ │ 执行监控   │ │ 主机分组   │ │ 告警配置   │        │
│  └───────────┘ └───────────┘ └───────────┘ └───────────┘        │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ RESTful API / WebSocket
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Server 调度中心                            │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐        │
│  │ 任务调度器 │ │ 配置管理   │ │ 状态管理   │ │ 事件总线   │        │
│  └───────────┘ └───────────┘ └───────────┘ └───────────┘        │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ QUIC 协议 (双向流通信)
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         Client 执行节点                           │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐        │
│  │ 任务引擎   │ │ 执行器池   │ │ 日志上报   │ │ 心跳保活   │        │
│  └───────────┘ └───────────┘ └───────────┘ └───────────┘        │
│                                                                  │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐                       │
│  │ Shell任务 │ │ HTTP任务   │ │ 自定义插件 │                       │
│  └───────────┘ └───────────┘ └───────────┘                       │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心术语

| 术语 | 定义 |
|-----|------|
| **任务 (Job)** | 需要定时执行的业务逻辑单元，包含执行内容、调度规则、目标分组等信息 |
| **任务实例 (Execution)** | 任务的一次具体执行记录，包含开始时间、结束时间、执行状态、输出日志 |
| **执行器 (Executor)** | 任务的具体执行载体，支持 Shell、HTTP、内置插件等多种类型 |
| **主机分组 (Host Group)** | 客户端主机的逻辑集合，任务可绑定到特定分组，实现隔离管理 |
| **调度器 (Scheduler)** | 服务端负责计算任务触发时间并下发执行指令的核心组件 |
| **任务引擎 (Task Engine)** | 客户端负责接收任务配置、管理执行器、上报执行状态的组件 |
| **Cron 表达式** | 任务调度规则的表达方式，兼容标准 Linux Cron 格式 |
| **执行状态快照 (Execution Snapshot)** | 客户端本地存储的任务执行记录，按天聚合统计，支持离线查询 |
| **状态同步 (State Sync)** | 客户端与服务端之间执行记录的双向同步机制 |

---

## 3. 功能需求

### 3.1 功能总览

| 优先级 | 功能模块 | 功能点 | 说明 |
|-------|---------|-------|------|
| P0 | 任务管理 | 任务 CRUD | 任务创建、编辑、删除、查询 |
| P0 | 任务管理 | Cron 调度 | 支持 Cron 表达式配置 |
| P0 | 任务管理 | 立即执行 | 手动触发任务立即执行一次 |
| P0 | 任务管理 | 启停控制 | 动态启用/禁用任务 |
| P0 | 任务分发 | 配置推送 | 服务端主动推送任务配置到客户端 |
| P0 | 任务分发 | 配置拉取 | 客户端启动时主动拉取任务配置 |
| P0 | 主机分组 | 分组管理 | 创建、编辑、删除主机分组 |
| P0 | 主机分组 | 分组绑定 | 任务绑定到特定分组执行 |
| P0 | 执行监控 | 实时状态 | 任务执行状态实时更新 |
| P0 | 执行监控 | 执行日志 | 查看任务执行的输出日志 |
| P0 | 执行监控 | 执行历史 | 查询历史执行记录 |
| P0 | 客户端状态 | 本地状态记录 | 客户端本地记录任务执行状态，支持离线查询 |
| P0 | 客户端状态 | 按天统计 | 按天聚合执行成功/失败次数 |
| P0 | 客户端状态 | 状态上报 | 定期上报本地执行记录到服务端 |
| P0 | 客户端状态 | 状态同步 | 离线重连后自动同步本地记录 |
| P1 | 高级调度 | 固定延迟 | 任务结束后延迟固定时间再次执行 |
| P1 | 高级调度 | 一次性任务 | 指定时间点执行一次后自动失效 |
| P1 | 高级调度 | 并发控制 | 同一任务的最大并发执行数 |
| P1 | 故障处理 | 失败重试 | 执行失败时的自动重试策略 |
| P1 | 故障处理 | 超时控制 | 任务执行超时自动终止 |
| P1 | 告警通知 | 执行告警 | 失败/超时时的通知方式 |
| P2 | 高级功能 | 任务依赖 | 任务完成后触发下游任务 |
| P2 | 高级功能 | 分片广播 | 大任务拆分到多个节点并行执行 |
| P2 | 高级功能 | 动态参数 | 支持任务执行时的动态参数传入 |

### 3.2 P0 功能详细说明

#### 3.2.1 任务管理

**FR-1.1 任务创建**
```
输入：
- 任务名称：必填，全局唯一
- 任务描述：选填
- 执行器类型：Shell / HTTP / 内置插件
- 执行内容：根据执行器类型不同
  • Shell：命令脚本
  • HTTP：URL、Method、Headers、Body
  • 插件：插件名称、参数
- 调度规则：Cron 表达式
- 目标分组：必填，支持多选
- 超时时间：默认 300s，范围 10s-3600s
- 失败重试：次数、间隔

处理：
1. 校验输入参数合法性
2. 持久化任务配置到数据库
3. 触发配置推送到目标分组的在线客户端

输出：任务 ID
```

**FR-1.2 任务编辑**
```
前置条件：任务存在且未执行中

输入：任务 ID、待更新字段

处理：
1. 校验任务状态（执行中不可编辑）
2. 更新数据库记录
3. 增量推送变更配置到客户端

输出：更新结果
```

**FR-1.3 任务启停控制**
```
实时生效，无需重启客户端

启用操作：
1. 更新任务状态为 ENABLED
2. 通知调度器纳入调度
3. 推送配置到客户端

禁用操作：
1. 更新任务状态为 DISABLED
2. 通知调度器移出调度
3. 通知客户端停止执行
```

**FR-1.4 手动触发**
```
绕过调度规则，立即执行任务

输入：任务 ID、动态参数（可选）

处理：
1. 校验任务状态
2. 直接下发执行指令到目标客户端
3. 记录为手动触发类型

输出：执行实例 ID
```

#### 3.2.2 任务分发机制

**FR-2.1 配置推送（服务端主动）**
```
触发时机：
- 任务创建/编辑/删除
- 任务启停操作
- 分组绑定变更

推送方式：
- 利用现有 QUIC 双向流通信
- 通过 Dispatcher 消息分发模块
- 支持单播/广播模式

消息格式（Protobuf）：
message TaskConfigPush {
    string task_id = 1;
    string action = 2;  // ADD/UPDATE/DELETE/ENABLE/DISABLE
    TaskConfig config = 3;
}

确认机制：
- 客户端收到后回复 ACK
- 超时未 ACK 则记录推送失败
- 支持重推（最多 3 次）
```

**FR-2.2 配置拉取（客户端主动）**
```
触发时机：
- 客户端首次启动
- 客户端重连成功
- 心跳时检测到配置版本变更

拉取内容：
- 客户端所属分组的所有任务配置
- 配置版本号（用于变更检测）

处理流程：
1. 客户端发送拉取请求（携带本地版本号）
2. 服务端返回增量或全量配置
3. 客户端更新本地任务缓存
4. 启动/停止相应的任务调度器
```

**FR-2.3 配置一致性保障**
```
版本管理：
- 每次任务变更递增版本号
- 客户端心跳携带当前版本号

一致性检查：
- 服务端定时比对客户端版本
- 发现不一致时主动推送更新

冲突解决：
- 服务端配置为准
- 客户端本地配置被覆盖
```

#### 3.2.3 主机分组管理

**FR-3.1 分组操作**
```
创建分组：
- 分组名称：必填，全局唯一
- 分组描述：选填
- 分组标签：选填，用于灵活筛选

编辑分组：
- 名称、描述可修改
- 有任务绑定时的名称变更需要级联更新

删除分组：
- 校验是否有任务绑定
- 有绑定时提示先解绑任务
```

**FR-3.2 客户端分组归属**
```
方式一：配置指定
- 客户端配置文件中指定 group_id

方式二：动态分配
- 客户端注册时根据规则自动分配
- 支持按 IP 段、主机名、标签等规则

方式三：手动调整
- Web 控制台手动调整客户端所属分组
```

**FR-3.3 分组与任务绑定**
```
绑定模式：
- 单一分组：任务只在指定分组执行
- 多分组：任务在多个分组都执行（复制模式）
- 全局：任务在所有客户端执行

绑定时机：
- 任务创建时指定
- 任务运行时动态增删分组
```

#### 3.2.4 执行监控

**FR-4.1 执行状态追踪**
```
状态定义：
- PENDING：已调度，等待执行
- RUNNING：执行中
- SUCCESS：执行成功
- FAILURE：执行失败
- TIMEOUT：执行超时
- CANCELLED：手动取消

状态流转：
PENDING → RUNNING → SUCCESS/FAILURE/TIMEOUT
              → CANCELLED

状态上报：
- 客户端定时上报执行进度（每 10s）
- 状态变更时立即上报
- 最终状态必须上报（确保一致性）
```

**FR-4.2 执行日志收集**
```
日志内容：
- 执行开始时间、结束时间、耗时
- 执行输出（stdout/stderr）
- 错误堆栈（失败时）
- 客户端信息（主机名、IP）

日志大小限制：
- 单次日志上限：10KB
- 超出部分截断，提示查看完整日志

日志存储：
- 热数据：数据库（最近 7 天）
- 冷数据：对象存储（归档）
```

**FR-4.3 执行历史查询**
```
查询维度：
- 按任务：查看某任务的所有执行记录
- 按时间：查看某时间段的执行记录
- 按状态：筛选成功/失败的记录
- 按客户端：查看某客户端执行的所有任务

列表展示：
- 执行时间、状态、耗时、客户端
- 操作：查看日志、重试（失败时）

统计聚合：
- 成功率统计
- 平均耗时统计
- 失败原因分布
```

#### 3.2.5 客户端本地状态记录

**FR-5.1 本地状态存储**
```
存储内容：
- 任务执行记录：每次执行的关键信息
- 按天统计：每日成功/失败次数汇总
- 执行日志：最近 N 次的执行输出

存储方式：
- 本地文件（JSON/BoltDB）
- 按天分片存储，便于清理
- 数据保留期：默认 7 天，可配置

文件结构：
~/.quicflow/tasks/
├── executions/
│   ├── 2025-01-09.json     # 当天执行记录
│   ├── 2025-01-08.json
│   └── ...
├── daily_stats/
│   ├── 2025-01-09.json     # 当天统计
│   └── ...
└── logs/
    ├── 2025-01-09/         # 按天分目录
    │   ├── task_001_exec_001.log
    │   └── ...
```

**FR-5.2 按天统计记录**
```
统计维度（按天）：
- 总执行次数
- 成功次数
- 失败次数
- 超时次数
- 取消次数
- 平均耗时
- 最大/最小耗时

数据结构：
{
  "date": "2025-01-09",
  "task_id": "task_001",
  "task_name": "日志清理",
  "stats": {
    "total": 24,
    "success": 23,
    "failure": 1,
    "timeout": 0,
    "cancelled": 0,
    "avg_duration_ms": 2300,
    "max_duration_ms": 3500,
    "min_duration_ms": 1800
  },
  "hourly_distribution": {
    "00": 1, "01": 1, "02": 1, ...
  },
  "last_updated": "2025-01-09T23:59:59Z"
}
```

**FR-5.3 状态上报机制**
```
上报时机：
1. 任务执行完成后立即上报
2. 定期批量上报（每 5 分钟）
3. 客户端重连成功后上报离线期间记录

上报内容：
message DailyStatsReport {
    string client_id = 1;
    string date = 2;           // YYYY-MM-DD
    repeated TaskStats stats = 3;
}

message TaskStats {
    string task_id = 1;
    int32 success_count = 2;
    int32 failure_count = 3;
    int64 total_duration_ms = 4;
}

上报策略：
- 实时上报：每次任务执行完成后
- 批量上报：聚合统计数据，减少网络开销
- 去重机制：服务端基于 execution_id 去重
- 失败重试：上报失败时本地暂存，下次重连时重试
```

**FR-5.4 离线状态处理**
```
离线执行：
1. 客户端断线期间，任务继续执行
2. 执行记录完整保存到本地
3. 统计数据正常更新

重连同步：
1. 重连成功后，触发离线数据同步
2. 批量上报离线期间的执行记录
3. 服务端确认后清理本地已同步数据

冲突处理：
- 以客户端本地记录为准（执行源的真理）
- 服务端基于 execution_id 去重合并
- 统计数据重新计算
```

**FR-5.5 本地数据查询接口**
```
客户端 CLI 查询：
# 查看今日执行统计
quicflow task stats --today

# 查看指定日期的执行记录
quicflow task history --date 2025-01-09

# 查看指定任务的执行统计
quicflow task stats --task-id task_001 --days 7

# 查看最近一次执行日志
quicflow task logs --task-id task_001 --last

输出示例：
┌─────────────────────────────────────────────────────────┐
│ 任务执行统计 - 2025-01-09                               │
├──────────┬────────┬────────┬────────┬────────┬────────┤
│ 任务      │ 总次数  │ 成功   │ 失败   │ 成功率 │ 平均耗时│
├──────────┼────────┼────────┼────────┼────────┼────────┤
│ 日志清理  │ 24     │ 24     │ 0      │ 100%   │ 2.3s   │
│ 数据备份  │ 1      │ 1      │ 0      │ 100%   │ 45.2s  │
│ 健康检查  │ 288    │ 285    │ 3      │ 98.9%  │ 0.5s   │
└──────────┴────────┴────────┴────────┴────────┴────────┘
```

#### 3.2.6 前端功能需求

**FR-6.1 任务管理界面**
```
功能清单：
- 任务列表：分页展示、多条件筛选（状态/分组/关键词）
- 任务创建：表单验证、Cron表达式校验、预览下次执行时间
- 任务编辑：在线编辑配置、即时生效
- 任务启停：一键切换运行状态
- 手动触发：立即执行任务、查看执行结果
- 批量操作：批量启用/禁用/删除
- Cron表达式辅助：预设模板、表达式生成器、下次执行预览

交互要求：
- 表格支持排序、列显示/隐藏
- 操作按钮支持快捷键
- 状态变化实时推送（WebSocket）
- 保存前校验、错误提示明确
```

**FR-6.2 执行监控界面**
```
功能清单：
- 实时状态：当前执行中的任务列表
- 执行历史：按时间/状态/客户端筛选
- 日志查看：支持实时追加、高亮、搜索
- 执行统计：成功率、平均耗时、失败原因分布
- 图表展示：趋势图、饼图、柱状图

交互要求：
- 执行日志支持自动滚动、可暂停
- 失败记录高亮显示、一键重试
- 支持导出日志（TXT/JSON）
- 图表支持时间范围选择、维度切换
```

**FR-6.3 分组管理界面**
```
功能清单：
- 分组列表：在线主机数、绑定任务数统计
- 分组创建/编辑：名称唯一性校验
- 主机管理：查看分组内主机、手动添加/移除
- 主机状态：在线/离线状态、最后心跳时间

交互要求：
- 支持拖拽主机到分组
- 主机列表支持批量操作
```

**FR-6.4 统计报表界面**
```
功能清单：
- 概览仪表盘：关键指标卡片
- 任务趋势：执行次数趋势图（日/周/月）
- 成功率统计：按任务/分组维度
- 失败分析：失败原因分布、Top失败任务
- 客户端统计：客户端执行分布

交互要求：
- 图表支持钻取（点击查看详情）
- 时间范围快捷选择（今天/7天/30天）
- 支持导出报表（Excel/PDF）
```

**FR-6.5 系统设置界面**
```
功能清单：
- 通知设置：告警通知配置
- 用户管理：用户列表、角色权限
- 操作日志：审计日志查询
- 系统配置：数据保留天数、并发限制
```

---

## 4. 非功能需求

### 4.1 性能要求

| 指标 | 要求 | 说明 |
|-----|------|-----|
| 调度精度 | ±1s | 任务触发时间与预期时间偏差 |
| 吞吐量 | 1000 tasks/s | 服务端每秒可触发的任务数 |
| 并发执行 | 10,000+ | 同时执行中的任务实例数 |
| 配置推送延迟 | <3s | 配置变更到客户端生效的时间 |
| 心跳间隔 | 15s | 与现有系统保持一致 |
| 本地存储写入 | <10ms | 单次执行记录写入延迟 |
| 统计查询 | <100ms | 本地统计查询响应时间 |

### 4.2 可靠性要求

| 指标 | 要求 | 说明 |
|-----|------|-----|
| 服务可用性 | 99.9% | 服务端正常运行时间占比 |
| 任务执行可靠性 | 至少一次 | 配置变更后确保客户端收到 |
| 数据持久性 | 99.99% | 任务配置和执行记录不丢失 |
| 故障恢复时间 | <5min | 服务端重启后恢复正常调度 |
| 本地数据完整性 | 100% | 客户端本地执行记录不丢失 |
| 离线数据同步 | 100% | 重连后离线数据全部同步成功 |

### 4.3 可扩展性要求

- **水平扩展**：调度器支持分布式部署，多实例协同工作
- **客户端扩展**：支持 10,000+ 客户端接入
- **执行器扩展**：支持自定义执行器插件开发

### 4.4 安全性要求

- **权限控制**：基于 RBAC 的任务操作权限
- **命令注入防护**：Shell 任务执行时进行参数校验和转义
- **通信加密**：复用现有 QUIC TLS 1.3 加密
- **审计日志**：记录所有任务操作的审计轨迹

### 4.5 前端非功能需求

#### 4.5.1 性能要求

| 指标 | 要求 | 说明 |
|-----|------|-----|
| 首屏加载 | <2s | 首次进入页面加载完成时间 |
| 路由切换 | <300ms | 页面间切换响应时间 |
| 列表渲染 | <500ms | 100条数据列表渲染时间 |
| 图表渲染 | <1s | 复杂图表渲染完成时间 |
| API 请求 | 并发支持 | 支持同时发起多个请求 |
| 实时更新 | <1s | WebSocket 消息推送延迟 |

#### 4.5.2 兼容性要求

| 类别 | 要求 |
|-----|------|
| 浏览器 | Chrome 90+, Firefox 88+, Safari 14+, Edge 90+ |
| 分辨率 | 最低 1366x768，推荐 1920x1080 |
| 设备 | 支持桌面端，平板端可用 |

#### 4.5.3 用户体验要求

- **响应式设计**：适配不同屏幕尺寸
- **加载反馈**：所有异步操作提供加载状态
- **错误提示**：友好的错误信息，提供解决建议
- **操作确认**：危险操作（删除、禁用）需二次确认
- **快捷键支持**：常用操作支持键盘快捷键
- **深色模式**：支持深色/浅色主题切换

#### 4.5.4 可访问性要求

- **键盘导航**：所有功能可通过键盘访问
- **语义化标签**：使用正确的 HTML5 语义标签
- **ARIA 标签**：为交互元素添加适当的 ARIA 属性
- **颜色对比度**：符合 WCAG 2.1 AA 标准

#### 4.5.5 国际化要求

- **多语言支持**：中文（默认）、英文
- **时区处理**：支持多时区显示
- **日期格式**：根据语言自动调整

#### 4.5.6 开发规范要求

- **代码规范**：遵循 ESLint + Prettier 规范
- **组件规范**：单文件组件 (SFC)，组件复用率 >60%
- **状态管理**：使用 Pinia 统一管理
- **API 调用**：统一封装，自动错误处理
- **日志记录**：前端错误日志上报

---

## 5. 数据模型

### 5.1 ER 图

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
|    tb_task   │     |  tb_group    │     | tb_execution |
├──────────────┤     ├──────────────┤     ├──────────────┤
| id           │──┐  │ id           │──┐  │ id           │
| name         │  │  │ name         │  │  │ task_id      │──┐
| description  │  │  │ description  │  │  │ client_id    │  │
| executor_type│  │  │ tags         │  │  │ status       │  │
| executor_config│ │  │ created_at   │  │  │ start_time   │  │
| cron_expr    │  │  └──────────────┘  │  │ end_time     │  │
| timeout      │  │        │           │  │ duration     │  │
| retry_count  │  │        │           │  │ exit_code    │  │
| retry_interval│ │        ▼           │  │ output       │  │
| status       │  │  ┌──────────────┐  │  │ error_msg    │  │
| created_at   │  │  │tb_task_group │  │  │ created_at   │  │
| updated_at   │  │  ├──────────────┤  │  └──────────────┘  │
└──────────────┘  │  │ task_id      │──┘                     │
                  │  │ group_id     │──┐                     │
                  │  └──────────────┘  │                     │
                  └────────────────────┼─────────────────────┘
                                      ▼
                            ┌──────────────┐
                            |   tb_client  |
                            ├──────────────┤
                            | id           │
                            | client_id    │
                            | group_id     │
                            | hostname     │
                            | ip           │
                            | version      │
                            | last_heartbeat│
                            └──────────────┘
```

### 5.2 核心表结构

```sql
-- 任务表
CREATE TABLE tb_task (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    name            VARCHAR(128) NOT NULL COMMENT '任务名称',
    description     VARCHAR(512) COMMENT '任务描述',
    executor_type   TINYINT NOT NULL COMMENT '执行器类型:1=Shell,2=HTTP,3=Plugin',
    executor_config TEXT NOT NULL COMMENT '执行器配置(JSON)',
    cron_expr       VARCHAR(64) NOT NULL COMMENT 'Cron表达式',
    timeout         INT NOT NULL DEFAULT 300 COMMENT '超时时间(秒)',
    retry_count     INT NOT NULL DEFAULT 0 COMMENT '重试次数',
    retry_interval  INT NOT NULL DEFAULT 60 COMMENT '重试间隔(秒)',
    concurrency     INT NOT NULL DEFAULT 1 COMMENT '最大并发数',
    status          TINYINT NOT NULL DEFAULT 1 COMMENT '状态:0=禁用,1=启用',
    created_by      VARCHAR(64) COMMENT '创建人',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_name (name),
    KEY idx_status (status)
) COMMENT='定时任务表';

-- 任务分组关联表
CREATE TABLE tb_task_group (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_id         BIGINT NOT NULL COMMENT '任务ID',
    group_id        BIGINT NOT NULL COMMENT '分组ID',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_task_group (task_id, group_id),
    KEY idx_group_id (group_id)
) COMMENT='任务分组关联表';

-- 主机分组表
CREATE TABLE tb_group (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    name            VARCHAR(64) NOT NULL COMMENT '分组名称',
    description     VARCHAR(256) COMMENT '分组描述',
    tags            VARCHAR(256) COMMENT '标签(逗号分隔)',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_name (name)
) COMMENT='主机分组表';

-- 执行记录表
CREATE TABLE tb_execution (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_id         BIGINT NOT NULL COMMENT '任务ID',
    task_name       VARCHAR(128) COMMENT '任务名称(冗余)',
    client_id       VARCHAR(64) NOT NULL COMMENT '客户端ID',
    group_id        BIGINT COMMENT '分组ID',
    execution_type  TINYINT NOT NULL DEFAULT 1 COMMENT '执行类型:1=定时,2=手动',
    status          TINYINT NOT NULL COMMENT '状态:1=Pending,2=Running,3=Success,4=Failed,5=Timeout,6=Cancelled',
    start_time      DATETIME COMMENT '开始时间',
    end_time        DATETIME COMMENT '结束时间',
    duration        INT COMMENT '执行耗时(毫秒)',
    exit_code       INT COMMENT '退出码',
    output          TEXT COMMENT '执行输出',
    error_msg       TEXT COMMENT '错误信息',
    retry_count     INT NOT NULL DEFAULT 0 COMMENT '重试次数',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    KEY idx_task_id (task_id),
    KEY idx_client_id (client_id),
    KEY idx_status (status),
    KEY idx_start_time (start_time)
) COMMENT='任务执行记录表';

-- 客户端表（扩展现有）
CREATE TABLE tb_client (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    client_id       VARCHAR(64) NOT NULL COMMENT '客户端ID',
    group_id        BIGINT COMMENT '所属分组ID',
    hostname        VARCHAR(128) COMMENT '主机名',
    ip              VARCHAR(64) COMMENT 'IP地址',
    task_version    BIGINT NOT NULL DEFAULT 0 COMMENT '任务配置版本',
    last_heartbeat  DATETIME COMMENT '最后心跳时间',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_client_id (client_id),
    KEY idx_group_id (group_id)
) COMMENT='客户端表';
```

### 5.3 客户端本地存储结构

```json
// 执行记录文件 ~/.quicflow/tasks/executions/2025-01-09.json
{
  "date": "2025-01-09",
  "client_id": "client-001",
  "executions": [
    {
      "execution_id": "exec_20250109_020000_001",
      "task_id": "task_001",
      "task_name": "日志清理",
      "status": "success",
      "start_time": "2025-01-09T02:00:00Z",
      "end_time": "2025-01-09T02:00:02Z",
      "duration_ms": 2300,
      "exit_code": 0,
      "synced": true
    }
  ]
}

// 按天统计文件 ~/.quicflow/tasks/daily_stats/2025-01-09.json
{
  "date": "2025-01-09",
  "client_id": "client-001",
  "tasks": {
    "task_001": {
      "task_name": "日志清理",
      "stats": {
        "total": 24,
        "success": 24,
        "failure": 0,
        "timeout": 0,
        "cancelled": 0,
        "avg_duration_ms": 2300
      },
      "hourly": {
        "00": 0, "01": 0, "02": 1, "03": 0, ...
      }
    }
  },
  "synced_to_server": true
}

// 待同步记录文件 ~/.quicflow/tasks/pending_sync.json
{
  "pending_executions": [
    {
      "execution_id": "exec_20250109_020000_001",
      "task_id": "task_001",
      "retry_count": 0,
      "last_sync_attempt": "2025-01-09T02:00:05Z"
    }
  ]
}
```

---

## 6. 交互流程

### 6.1 客户端启动与配置同步流程

```
Client                    Server                    Dispatcher
  │                          │                            │
  ├──────────────────────────(1. Register & Auth)─────────>│
  │                          │                            │
  │<─────────────────────────(2. Register Success)─────────┤
  │                          │                            │
  ├──────────────────────────(3. Pull Task Config)────────>│
  │                          │                            │
  │                          │<─(4. Query Tasks by Group)─┤
  │                          │                            │
  │<─────────────────────────(5. Return Task Config)───────┤
  │                          │                            │
  │[6. Initialize Task Engine]                             │
  │                          │                            │
  │<─(7. Start Heartbeat, every 15s)───────────────────────┤
```

### 6.2 任务调度与执行流程

```
Scheduler               Dispatcher              Client              Database
   │                        │                      │                   │
   ├─(1. Calculate Trigger)───│                      │                   │
   │                        │                      │                   │
   ├──────────────────────────(2. Dispatch to Group)─────────────────────>│
   │                        │                      │                   │
   │                        │<─(3. Deliver to Client)─────────────────────│
   │                        │                      │                   │
   │                        │                      │[4. Execute Task]   │
   │                        │                      │                   │
   │                        │<──────(5. Report Progress)─────────────────│
   │                        │                      │                   │
   │                        │                      ├─(6. Save Log)─────>│
   │                        │                      │                   │
   │                        │<──────(7. Report Final Status)─────────────│
   │                        │                      │                   │
   │<───────(8. Update Execution Record)─────────────────────────────────>│
```

### 6.3 配置变更推送流程

```
    Admin                   Server                Dispatcher            Client
      │                       │                       │                   │
      ├─(1. Update Task)──────>│                       │                   │
      │                       │                       │                   │
      │                       ├─(2. Save to DB)───────>│                   │
      │                       │                       │                   │
      │<─(3. Update Success)──┤                       │                   │
      │                       │                       │                   │
      │                       ├───────────────────────(4. Push Config)───────────>
      │                       │                       │                   │
      │                       │                       │<──(5. ACK)────────────────┤
      │                       │                       │                   │
      │                       │                       │                   │[6. Apply Config]
      │                       │                       │                   │
      │                       │                       │<──(7. Confirm)─────────────┤
```

### 6.4 失败重试流程

```
  Scheduler               Client               Dispatcher            Database
     │                       │                      │                    │
     │<─(1. Task Failed)──────┤                      │                    │
     │                       │                      │                    │
     ├─(2. Check Retry Policy)────────────────────────────────────────────>│
     │                       │                      │                    │
     │[3. Wait retry_interval]                      │                    │
     │                       │                      │                    │
     ├───────────────────────(4. Retry Task)───────────────────────────────>│
     │                       │                      │                    │
     │                       │                      │<──(5. Update retry_count)───┤
     │                       │                      │                    │
     │<─(6. Execution Result)───────────────────────────────────────────────────┤
```

### 6.5 客户端本地状态与离线同步流程

```
 Client (Offline)        Client Storage        Server (Online)
     │                         │                      │
     │ [任务调度触发]            │                      │
     │                         │                      │
     ├─(1. 执行任务)────────────>│                      │
     │                         │                      │
     │<─(2. 返回结果)────────────┤                      │
     │                         │                      │
     ├─(3. 记录到本地)──────────>│                      │
     │                         │                      │
     ├─(4. 更新按天统计)────────>│                      │
     │                         │                      │
     │ [网络断开，任务继续执行...]                        │
     │                         │                      │
     ├─(5. 执行更多任务)────────>│                      │
     │                         │                      │
     │<─────────────────────────┤                      │
     │ [5条离线记录已存储]        │                      │
     │                         │                      │
     │ [网络恢复]                │                      │
     │                         │                      │
     ├──────────────────────────────────────(6. 重连成功)──────>│
     │                         │                      │
     │                         ├──────────────────────(7. 批量上报离线记录)─────>│
     │                         │                      │
     │                         │<───────(8. 确认已接收)──────────────────────────┤
     │                         │                      │
     │                         ├─(9. 标记记录已同步，移出待同步队列)            │
     │                         │                      │
     │ [离线期间状态完全保留，同步成功]                       │
```

### 6.6 状态上报与同步流程

```
    Client                Dispatcher             Server            Database
      │                       │                    │                   │
      ├─(1. 任务执行完成)      │                    │                   │
      │                       │                    │                   │
      ├─(2. 写入本地存储)──────>│                    │                   │
      │                       │                    │                   │
      ├─(3. 更新按天统计)──────>│                    │                   │
      │                       │                    │                   │
      ├──────────────────────────(4. 上报执行结果)──────────────────────────────>│
      │                       │                    │                   │
      │                       │                    ├─(5. 保存到DB)──────>│
      │                       │                    │                   │
      │                       │<───────(6. 返回确认)──────────────────────────────┤
      │                       │                    │                   │
      ├─(7. 标记本地记录已同步)                      │                   │
      │                       │                    │                   │
      │ [定期批量上报(每5分钟)]                        │                   │
      ├──────────────────────────(8. 上报统计数据聚合)───────────────────────────>│
      │                       │                    │                   │
```

---

## 7. 界面原型

### 7.1 任务管理页面

```
┌─────────────────────────────────────────────────────────────────────────┐
│  定时任务管理                                    [+ 新建任务]    [批量操作▼]│
├─────────────────────────────────────────────────────────────────────────┤
│  搜索: [____________]  状态: [全部▼]  分组: [全部▼]        [查询] [重置]│
├─────────────────────────────────────────────────────────────────────────┤
│  ┌───┬──────────┬──────────┬──────────┬────────┬──────────┬────────┐   │
│  │ □ │ 任务名称   │ 执行器    │ Cron表达式 │ 分组    │ 状态     │ 操作    │   │
│  ├───┼──────────┼──────────┼──────────┼────────┼──────────┼────────┤   │
│  │ □ │ 日志清理   │ Shell    │ 0 2 * * * │ default │ ● 运行中  │ [...]  │   │
│  │ □ │ 数据备份   │ HTTP     │ 0 3 * * * │ backup  │ ○ 已停止 │ [...]  │   │
│  │ □ │ 健康检查   │ Plugin   │ */5 * * * │ all     │ ● 运行中  │ [...]  │   │
│  └───┴──────────┴──────────┴──────────┴────────┴──────────┴────────┘   │
│                                                                          │
│  共 3 条记录  [1] 2 3 >                                                  │
└─────────────────────────────────────────────────────────────────────────┘

[...] 操作菜单：
┌────────────┐
│ 📋 查看详情  │
│ ▶️ 立即执行   │
│ ⏸ 暂停     │
│ ✏️ 编辑     │
│ 🗑 删除     │
│ 📊 执行历史  │
└────────────┘
```

### 7.2 任务创建/编辑弹窗

```
┌─────────────────────────────────────────────────────────────────────────┐
│  新建定时任务                                                       [×] │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  基本信息                                                               │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ 任务名称 * [日志清理任务____________________________]            │  │
│  │ 任务描述   [清理7天前的日志文件__________________________]       │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  调度配置                                                               │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ Cron表达式 * [0 2 * * *_______]  [💡 帮助]  最近执行: 02:00, 明天  │  │
│  │           预计下次执行: 2025-01-10 02:00:00                        │  │
│  │ 超时时间   [300_______] 秒  (范围: 10-3600)                       │  │
│  │ 最大并发   [1_______]     (同时执行的最大实例数)                   │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  执行器配置                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ 执行器类型 (•) Shell  () HTTP  () 插件                            │  │
│  │                                                                   │  │
│  │ 执行命令 *                                                        │  │
│  │ ┌─────────────────────────────────────────────────────────────┐  │  │
│  │ │ find /var/log -name "*.log" -mtime +7 -delete              │  │  │
│  │ └─────────────────────────────────────────────────────────────┘  │  │
│  │ 工作目录   [/var/log___________________________]                │  │
│  │ 环境变量   [PATH=/usr/local/bin:$PATH_______________]           │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  高级配置                                                               │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ 失败重试   重试次数 [0__] 次  间隔 [60__] 秒                      │  │
│  │ 目标分组   [×] default  [+ 选择分组]                             │  │
│  │ 执行告警   (☑) 失败时通知  钉钉群 [_________________]             │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│                              [取消]  [保存并启用]                        │
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.3 执行监控页面

```
┌─────────────────────────────────────────────────────────────────────────┐
│  执行监控 - 日志清理任务                                        [← 返回]│
├─────────────────────────────────────────────────────────────────────────┤
│  任务信息: 日志清理任务 │ Cron: 0 2 * * * │ 分组: default                 │
│                                                                          │
│  状态统计                                                               │
│  ┌──────────────┬──────────────┬──────────────┬──────────────┬────────┐│
│  │ 今日执行      │ 成功         │ 失败         │ 平均耗时      │ 成功率  ││
│  │ 1次          │ 1次 (100%)   │ 0次 (0%)     │ 2.3s         │ 100%   ││
│  └──────────────┴──────────────┴──────────────┴──────────────┴────────┘│
│                                                                          │
│  执行历史                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐│
│  │ 2025-01-10 02:00  │ client-01 │ SUCCESS │ 2.3s │ [查看日志] [重试] ││
│  │ 2025-01-09 02:00  │ client-01 │ SUCCESS │ 2.1s │ [查看日志] [重试] ││
│  │ 2025-01-08 02:00  │ client-01 │ SUCCESS │ 2.5s │ [查看日志] [重试] ││
│  └────────────────────────────────────────────────────────────────────┘│
│                                                                          │
│  ┌─ 执行日志详情 ──────────────────────────────────────────────────[×]─┐│
│  │ 执行实例: #123456                                                   ││
│  │ 客户端: client-01 (192.168.1.100)                                   ││
│  │ 执行时间: 2025-01-10 02:00:00 - 02:00:02                            ││
│  │ 状态: ● SUCCESS                                                     ││
│  │ ┌────────────────────────────────────────────────────────────────┐││
│  │ │ > find /var/log -name "*.log" -mtime +7 -delete                 │││
│  │ │                                                                 │││
│  │ │ [2025-01-10 02:00:00] 开始执行...                               │││
│  │ │ [2025-01-10 02:00:02] 清理完成，删除 15 个文件                   │││
│  │ │                                                                 │││
│  │ │ 执行成功，退出码: 0                                             │││
│  │ └────────────────────────────────────────────────────────────────┘││
│  └────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.4 主机分组管理页面

```
┌─────────────────────────────────────────────────────────────────────────┐
│  主机分组管理                                    [+ 新建分组]    [刷新]  │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │ 分组名称        │ 描述              │ 在线主机 │ 绑定任务 │ 操作    ││
│  ├─────────────────────────────────────────────────────────────────────┤│
│  │ default        │ 默认分组          │ 15      │ 3       │ [...]   ││
│  │ backup         │ 备份服务器        │ 3       │ 1       │ [...]   ││
│  │ production     │ 生产环境          │ 25      │ 5       │ [...]   ││
│  │ staging        │ 预发环境          │ 8       │ 2       │ [...]   ││
│  └─────────────────────────────────────────────────────────────────────┘│
│                                                                          │
│  ┌─ 分组详情: default ─────────────────────────────────────────────[×]─┐│
│  │ 分组名称: default      描述: 默认分组                                ││
│  │ 标签: base,common                                                    ││
│  │                                                                   ││
│  │ 主机列表 (15)                                                        ││
│  │ ┌─────────────────────────────────────────────────────────────────┐││
│  │ │ client-01  │ 192.168.1.100  │ ● 在线 │ 1分钟前                │││
│  │ │ client-02  │ 192.168.1.101  │ ● 在线 │ 30秒前                 │││
│  │ │ client-03  │ 192.168.1.102  │ ○ 离线 │ 1小时前                │││
│  │ └─────────────────────────────────────────────────────────────────┘││
│  │                              [添加主机]  [移出分组]                 ││
│  └────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 8. API 接口定义

### 8.1 任务管理接口

```golang
// 任务列表
GET /api/v1/tasks
Query: page=1&page_size=20&status=1&group_id=1&keyword=xxx
Response: {
    "code": 0,
    "data": {
        "total": 100,
        "items": [{
            "id": 1,
            "name": "日志清理",
            "description": "清理过期日志",
            "executor_type": 1,
            "cron_expr": "0 2 * * *",
            "groups": ["default"],
            "status": 1,
            "next_exec_time": "2025-01-10T02:00:00Z"
        }]
    }
}

// 创建任务
POST /api/v1/tasks
Body: {
    "name": "日志清理",
    "description": "清理过期日志",
    "executor_type": 1,
    "executor_config": {"command": "find /var/log ...", "work_dir": "/var/log"},
    "cron_expr": "0 2 * * *",
    "timeout": 300,
    "retry_count": 3,
    "retry_interval": 60,
    "group_ids": [1, 2]
}

// 更新任务
PUT /api/v1/tasks/:id
Body: (同创建)

// 删除任务
DELETE /api/v1/tasks/:id

// 启用/禁用任务
POST /api/v1/tasks/:id/enable
POST /api/v1/tasks/:id/disable

// 立即执行任务
POST /api/v1/tasks/:id/trigger
Body: {"params": {"key": "value"}}
Response: {"code": 0, "data": {"execution_id": 12345}}

// 获取任务详情
GET /api/v1/tasks/:id

// Cron 表达式解析预览
GET /api/v1/tasks/cron/parse?expr=0 2 * * *
Response: {
    "code": 0,
    "data": {
        "next_executions": [
            "2025-01-10T02:00:00Z",
            "2025-01-11T02:00:00Z"
        ]
    }
}
```

### 8.2 分组管理接口

```golang
// 分组列表
GET /api/v1/groups
Response: {
    "code": 0,
    "data": [{
        "id": 1,
        "name": "default",
        "description": "默认分组",
        "tags": ["base", "common"],
        "online_count": 15,
        "task_count": 3
    }]
}

// 创建分组
POST /api/v1/groups
Body: {"name": "production", "description": "生产环境", "tags": ["prod"]}

// 更新分组
PUT /api/v1/groups/:id

// 删除分组
DELETE /api/v1/groups/:id

// 获取分组下的客户端
GET /api/v1/groups/:id/clients
```

### 8.3 执行监控接口

```golang
// 执行历史
GET /api/v1/executions
Query: task_id=1&client_id=xxx&status=3&start_time=xxx&end_time=xxx&page=1
Response: {
    "code": 0,
    "data": {
        "total": 100,
        "items": [{
            "id": 12345,
            "task_id": 1,
            "task_name": "日志清理",
            "client_id": "client-01",
            "status": 3,
            "start_time": "2025-01-10T02:00:00Z",
            "end_time": "2025-01-10T02:00:02Z",
            "duration": 2300,
            "retry_count": 0
        }]
    }
}

// 执行详情
GET /api/v1/executions/:id

// 执行日志
GET /api/v1/executions/:id/logs
Response: {
    "code": 0,
    "data": {
        "output": "[2025-01-10 02:00:00] 开始执行...\n...",
        "error": "",
        "truncated": false
    }
}

// 执行统计
GET /api/v1/executions/stats?task_id=1&date_range=7d
Response: {
    "code": 0,
    "data": {
        "total_count": 7,
        "success_count": 6,
        "failure_count": 1,
        "success_rate": 85.7,
        "avg_duration": 2300
    }
}
```

---

## 9. QUIC 消息协议

### 9.1 消息类型扩展

```protobuf
// 在现有 protocol/proto/message.proto 中扩展

enum MessageType {
    // 现有类型...
    PING = 0;
    PONG = 1;
    DATA = 2;
    ACK = 3;

    // 新增任务调度类型
    TASK_CONFIG_PUSH = 10;       // 服务端推送任务配置
    TASK_CONFIG_PULL = 11;       // 客户端拉取任务配置
   _TASK_CONFIG_RESPONSE = 12;   // 任务配置响应
    TASK_EXECUTION = 13;         // 任务执行指令
    TASK_PROGRESS = 14;          // 任务执行进度上报
    TASK_RESULT = 15;            // 任务执行结果上报
    DAILY_STATS_REPORT = 16;     // 按天统计数据上报
    OFFLINE_SYNC_REQUEST = 17;   // 离线数据同步请求
    OFFLINE_SYNC_RESPONSE = 18;  // 离线数据同步响应
}

// 任务配置推送
message TaskConfigPush {
    repeated TaskConfig tasks = 1;
    int64 version = 2;           // 配置版本号
    PushAction action = 3;       // 推送动作
}

enum PushAction {
    ADD = 0;         // 新增任务
    UPDATE = 1;      // 更新任务
    DELETE = 2;      // 删除任务
    FULL_SYNC = 3;   // 全量同步
}

// 任务配置
message TaskConfig {
    string id = 1;
    string name = 2;
    ExecutorType executor_type = 3;
    map<string, string> executor_config = 4;
    string cron_expr = 5;
    int32 timeout = 6;
    int32 retry_count = 7;
    int32 retry_interval = 8;
    bool enabled = 9;
}

enum ExecutorType {
    SHELL = 0;
    HTTP = 1;
    PLUGIN = 2;
}

// 任务执行指令
message TaskExecution {
    string task_id = 1;
    string task_name = 2;
    string execution_id = 3;     // 执行实例ID
    ExecutorType executor_type = 4;
    map<string, string> executor_config = 5;
    int32 timeout = 6;
    map<string, string> params = 7;  // 动态参数
    int64 scheduled_time = 8;     // 调度时间
}

// 任务执行进度
message TaskProgress {
    string execution_id = 1;
    string task_id = 2;
    ExecutionStatus status = 3;
    int64 started_at = 4;
    string output = 5;           // 增量输出
    int32 output_offset = 6;     // 输出偏移量
}

enum ExecutionStatus {
    PENDING = 0;
    RUNNING = 1;
    SUCCESS = 2;
    FAILURE = 3;
    TIMEOUT = 4;
    CANCELLED = 5;
}

// 任务执行结果
message TaskResult {
    string execution_id = 1;
    string task_id = 2;
    ExecutionStatus status = 3;
    int64 started_at = 4;
    int64 finished_at = 5;
    int32 exit_code = 6;
    string output = 7;           // 完整输出
    string error = 8;            // 错误信息
    int32 retry_count = 9;
}

// 按天统计数据上报
message DailyStatsReport {
    string client_id = 1;
    string date = 2;             // YYYY-MM-DD
    repeated TaskStats task_stats = 3;
    int64 report_time = 4;
}

message TaskStats {
    string task_id = 1;
    string task_name = 2;
    int32 success_count = 3;
    int32 failure_count = 4;
    int32 timeout_count = 5;
    int32 cancelled_count = 6;
    int64 total_duration_ms = 7;
    int32 max_duration_ms = 8;
    int32 min_duration_ms = 9;
}

// 离线数据同步请求
message OfflineSyncRequest {
    string client_id = 1;
    int64 last_sync_time = 2;    // 上次成功同步时间
    int32 record_count = 3;      // 待同步记录数
}

// 离线数据同步响应
message OfflineSyncResponse {
    bool success = 1;
    string message = 2;
    int64 synced_count = 3;     // 成功同步的记录数
    int64 server_time = 4;       // 服务端时间
}
```

---

## 10. 技术实现要点

### 10.1 服务端调度器设计

```go
// pkg/scheduler/scheduler.go

type Scheduler struct {
    config      *Config
    taskStore   TaskStore
    dispatcher  *dispatcher.Dispatcher
    cron        *cron.Cron
    executors   map[string]*TaskExecutor
}

// 任务执行器
type TaskExecutor struct {
    task        *model.Task
    groups      []string
    clients     []*session.Client
    dispatcher  *dispatcher.Dispatcher
}

func (s *Scheduler) AddTask(task *model.Task) error {
    // 1. 解析 Cron 表达式
    schedule, err := cron.ParseStandard(task.CronExpr)
    if err != nil {
        return err
    }

    // 2. 创建执行器
    executor := &TaskExecutor{
        task:       task,
        groups:     task.Groups,
        dispatcher: s.dispatcher,
    }

    // 3. 添加到调度器
    s.cron.Schedule(schedule, executor)

    return nil
}

func (e *TaskExecutor) Run() {
    // 获取目标分组的在线客户端
    clients := e.getTargetClients()

    // 创建执行实例
    execution := &model.Execution{
        TaskID:    e.task.ID,
        Status:    model.StatusPending,
        CreatedAt: time.Now(),
    }

    // 下发执行指令
    for _, client := range clients {
        msg := &protocol.TaskExecution{
            TaskId:      e.task.ID,
            ExecutionId: execution.ID,
            // ...
        }
        e.dispatcher.SendToClient(client.ID, msg)
    }
}
```

### 10.2 客户端任务引擎设计

```go
// pkg/client/task/engine.go

type TaskEngine struct {
    clientID    string
    groupID     string
    tasks       map[string]*LocalTask
    executors   map[model.ExecutorType]Executor
    dispatcher  *dispatcher.Dispatcher
    store       ExecutionStore
}

// 本地任务
type LocalTask struct {
    config      *protocol.TaskConfig
    cron        *cron.Cron
    nextRun     time.Time
}

func (e *TaskEngine) ApplyConfig(push *protocol.TaskConfigPush) error {
    for _, task := range push.Tasks {
        switch push.Action {
        case protocol.ADD, protocol.UPDATE:
            e.addOrUpdateTask(task)
        case protocol.DELETE:
            e.removeTask(task.Id)
        }
    }
    return nil
}

func (e *TaskEngine) Execute(execMsg *protocol.TaskExecution) error {
    // 获取执行器
    executor := e.executors[execMsg.ExecutorType]

    // 创建执行上下文
    ctx := &ExecutionContext{
        ExecutionID: execMsg.ExecutionId,
        TaskID:      execMsg.TaskId,
        Config:      execMsg.ExecutorConfig,
        Timeout:     time.Duration(execMsg.Timeout) * time.Second,
    }

    // 异步执行
    go func() {
        // 上报开始
        e.reportProgress(&protocol.TaskProgress{
            ExecutionId: ctx.ExecutionID,
            Status:      protocol.RUNNING,
            StartedAt:   time.Now().Unix(),
        })

        // 执行任务
        result := executor.Execute(ctx)

        // 保存到本地存储
        e.store.Save(result)

        // 更新按天统计
        e.stats.Update(result)

        // 上报结果
        e.reportResult(result)
    }()

    return nil
}
```

### 10.3 客户端本地存储实现

```go
// pkg/client/task/local_storage.go

import (
    "encoding/json"
    "os"
    "path/filepath"
    "sync"
    "time"
)

// LocalStorage 客户端本地存储
type LocalStorage struct {
    clientID    string
    basePath    string
    retention   int // 数据保留天数，默认7天
    mu          sync.RWMutex
}

// ExecutionRecord 执行记录
type ExecutionRecord struct {
    ExecutionID string    `json:"execution_id"`
    TaskID      string    `json:"task_id"`
    TaskName    string    `json:"task_name"`
    Status      string    `json:"status"`
    StartTime   time.Time `json:"start_time"`
    EndTime     time.Time `json:"end_time"`
    DurationMs  int64     `json:"duration_ms"`
    ExitCode    int       `json:"exit_code"`
    Synced      bool      `json:"synced"`
}

// DailyStats 按天统计
type DailyStats struct {
    Date        string                   `json:"date"`
    ClientID    string                   `json:"client_id"`
    Tasks       map[string]*TaskStats    `json:"tasks"`
    Synced      bool                     `json:"synced_to_server"`
}

// TaskStats 任务统计
type TaskStats struct {
    TaskName       string            `json:"task_name"`
    SuccessCount   int32             `json:"success_count"`
    FailureCount   int32             `json:"failure_count"`
    TimeoutCount   int32             `json:"timeout_count"`
    CancelledCount int32             `json:"cancelled_count"`
    AvgDurationMs  int64             `json:"avg_duration_ms"`
    MaxDurationMs  int32             `json:"max_duration_ms"`
    MinDurationMs  int32             `json:"min_duration_ms"`
    Hourly         map[string]int32  `json:"hourly"`
}

func NewLocalStorage(clientID, basePath string, retention int) *LocalStorage {
    return &LocalStorage{
        clientID:  clientID,
        basePath:  basePath,
        retention: retention,
    }
}

// SaveExecution 保存执行记录
func (s *LocalStorage) SaveExecution(record *ExecutionRecord) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    date := record.StartTime.Format("2006-01-02")
    filePath := filepath.Join(s.basePath, "executions", date+".json")

    // 读取现有记录
    var dayRecords struct {
        Date       string             `json:"date"`
        ClientID   string             `json:"client_id"`
        Executions []ExecutionRecord  `json:"executions"`
    }

    if data, err := os.ReadFile(filePath); err == nil {
        json.Unmarshal(data, &dayRecords)
    } else {
        dayRecords.Date = date
        dayRecords.ClientID = s.clientID
    }

    // 添加新记录
    dayRecords.Executions = append(dayRecords.Executions, *record)

    // 写入文件
    os.MkdirAll(filepath.Dir(filePath), 0755)
    data, _ := json.MarshalIndent(dayRecords, "", "  ")
    return os.WriteFile(filePath, data, 0644)
}

// UpdateDailyStats 更新按天统计
func (s *LocalStorage) UpdateDailyStats(record *ExecutionRecord) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    date := record.StartTime.Format("2006-01-02")
    filePath := filepath.Join(s.basePath, "daily_stats", date+".json")

    // 读取现有统计
    var stats DailyStats
    if data, err := os.ReadFile(filePath); err == nil {
        json.Unmarshal(data, &stats)
    } else {
        stats = DailyStats{
            Date:     date,
            ClientID: s.clientID,
            Tasks:    make(map[string]*TaskStats),
        }
    }

    // 更新统计
    taskStats, exists := stats.Tasks[record.TaskID]
    if !exists {
        taskStats = &TaskStats{
            TaskName: record.TaskName,
            Hourly:   make(map[string]int32),
        }
        stats.Tasks[record.TaskID] = taskStats
    }

    taskStats.TotalCount++
    switch record.Status {
    case "success":
        taskStats.SuccessCount++
    case "failure":
        taskStats.FailureCount++
    case "timeout":
        taskStats.TimeoutCount++
    case "cancelled":
        taskStats.CancelledCount++
    }

    // 更新耗时统计
    if taskStats.MaxDurationMs < int32(record.DurationMs) {
        taskStats.MaxDurationMs = int32(record.DurationMs)
    }
    if taskStats.MinDurationMs == 0 || taskStats.MinDurationMs > int32(record.DurationMs) {
        taskStats.MinDurationMs = int32(record.DurationMs)
    }

    // 更新小时分布
    hour := record.StartTime.Format("15")
    taskStats.Hourly[hour]++

    // 写入文件
    os.MkdirAll(filepath.Dir(filePath), 0755)
    data, _ := json.MarshalIndent(stats, "", "  ")
    return os.WriteFile(filePath, data, 0644)
}

// GetPendingSync 获取待同步记录
func (s *LocalStorage) GetPendingSync() ([]ExecutionRecord, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    var pending []ExecutionRecord

    // 扫描最近7天的记录
    for i := 0; i < s.retention; i++ {
        date := time.Now().AddDate(0, 0, -i).Format("2006-01-02")
        filePath := filepath.Join(s.basePath, "executions", date+".json")

        var dayRecords struct {
            Executions []ExecutionRecord `json:"executions"`
        }

        if data, err := os.ReadFile(filePath); err == nil {
            json.Unmarshal(data, &dayRecords)
            for _, record := range dayRecords.Executions {
                if !record.Synced {
                    pending = append(pending, record)
                }
            }
        }
    }

    return pending, nil
}

// MarkSynced 标记记录已同步
func (s *LocalStorage) MarkSynced(executionID string) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    // 扫描文件找到对应记录并更新
    for i := 0; i < s.retention; i++ {
        date := time.Now().AddDate(0, 0, -i).Format("2006-01-02")
        filePath := filepath.Join(s.basePath, "executions", date+".json")

        data, err := os.ReadFile(filePath)
        if err != nil {
            continue
        }

        var dayRecords struct {
            Executions []ExecutionRecord `json:"executions"`
        }
        json.Unmarshal(data, &dayRecords)

        updated := false
        for j, record := range dayRecords.Executions {
            if record.ExecutionID == executionID && !record.Synced {
                dayRecords.Executions[j].Synced = true
                updated = true
            }
        }

        if updated {
            newData, _ := json.MarshalIndent(dayRecords, "", "  ")
            os.WriteFile(filePath, newData, 0644)
            return nil
        }
    }

    return os.ErrNotExist
}

// CleanupExpired 清理过期数据
func (s *LocalStorage) CleanupExpired() error {
    s.mu.Lock()
    defer s.mu.Unlock()

    cutoffDate := time.Now().AddDate(0, 0, -s.retention)

    // 清理执行记录
    execDir := filepath.Join(s.basePath, "executions")
    if entries, err := os.ReadDir(execDir); err == nil {
        for _, entry := range entries {
            if entry.IsDir() {
                continue
            }
            date, err := time.Parse("2006-01-02", strings.TrimSuffix(entry.Name(), ".json"))
            if err == nil && date.Before(cutoffDate) {
                os.Remove(filepath.Join(execDir, entry.Name()))
            }
        }
    }

    // 清理统计数据
    statsDir := filepath.Join(s.basePath, "daily_stats")
    if entries, err := os.ReadDir(statsDir); err == nil {
        for _, entry := range entries {
            if entry.IsDir() {
                continue
            }
            date, err := time.Parse("2006-01-02", strings.TrimSuffix(entry.Name(), ".json"))
            if err == nil && date.Before(cutoffDate) {
                os.Remove(filepath.Join(statsDir, entry.Name()))
            }
        }
    }

    return nil
}

// GetDailyStats 获取指定日期的统计
func (s *LocalStorage) GetDailyStats(date string) (*DailyStats, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    filePath := filepath.Join(s.basePath, "daily_stats", date+".json")
    data, err := os.ReadFile(filePath)
    if err != nil {
        return nil, err
    }

    var stats DailyStats
    err = json.Unmarshal(data, &stats)
    return &stats, err
}
```

### 10.4 离线同步管理器

```go
// pkg/client/task/sync_manager.go

// SyncManager 离线同步管理器
type SyncManager struct {
    storage     *LocalStorage
    dispatcher  *dispatcher.Dispatcher
    clientID    string
    syncInterval time.Duration
}

func NewSyncManager(storage *LocalStorage, dispatcher *dispatcher.Dispatcher, clientID string) *SyncManager {
    return &SyncManager{
        storage:      storage,
        dispatcher:   dispatcher,
        clientID:     clientID,
        syncInterval: 5 * time.Minute,
    }
}

// Start 启动同步管理器
func (m *SyncManager) Start(ctx context.Context) {
    // 立即同步待同步数据
    m.syncPending()

    // 定期同步统计数据
    ticker := time.NewTicker(m.syncInterval)
    go func() {
        for {
            select {
            case <-ticker.C:
                m.syncDailyStats()
            case <-ctx.Done():
                ticker.Stop()
                return
            }
        }
    }()
}

// OnReconnect 重连时触发
func (m *SyncManager) OnReconnect() {
    m.syncPending()
    m.syncDailyStats()
}

// syncPending 同步待同步记录
func (m *SyncManager) syncPending() {
    pending, err := m.storage.GetPendingSync()
    if err != nil || len(pending) == 0 {
        return
    }

    // 批量上报
    for _, record := range pending {
        m.reportExecution(&record)
    }
}

// syncDailyStats 同步统计数据
func (m *SyncManager) syncDailyStats() {
    today := time.Now().Format("2006-01-02")
    stats, err := m.storage.GetDailyStats(today)
    if err != nil {
        return
    }

    // 构造上报消息
    var taskStats []*protocol.TaskStats
    for taskID, stat := range stats.Tasks {
        taskStats = append(taskStats, &protocol.TaskStats{
            TaskId:         taskID,
            TaskName:       stat.TaskName,
            SuccessCount:   stat.SuccessCount,
            FailureCount:   stat.FailureCount,
            TimeoutCount:   stat.TimeoutCount,
            CancelledCount: stat.CancelledCount,
            TotalDurationMs: stat.AvgDurationMs * int64(stat.TotalCount),
        })
    }

    report := &protocol.DailyStatsReport{
        ClientId:   m.clientID,
        Date:       today,
        TaskStats:  taskStats,
        ReportTime: time.Now().Unix(),
    }

    m.dispatcher.SendToServer(protocol.DAILY_STATS_REPORT, report)
}
```

### 10.5 配置一致性保障

```go
// pkg/scheduler/config_sync.go

type ConfigSync struct {
    store      TaskStore
    dispatcher *dispatcher.Dispatcher
    version    int64
}

func (s *ConfigSync) CheckClientVersions() {
    // 获取所有客户端
    clients := session.GetAllClients()

    for _, client := range clients {
        // 比对版本
        if client.TaskVersion < s.version {
            // 推送更新
            s.pushToClient(client)
        }
    }
}

func (s *ConfigSync) OnTaskChange(task *model.Task, action PushAction) {
    s.version++

    // 获取目标分组的客户端
    clients := s.getClientsByGroups(task.Groups)

    // 推送配置
    for _, client := range clients {
        s.pushToClient(client)
    }
}
```

---

## 11. 验收标准

### 11.1 功能验收

| 编号 | 验收项 | 验收标准 |
|-----|-------|---------|
| F1 | 任务创建 | 可通过 Web 界面创建任务，配置保存成功，推送到客户端 |
| F2 | 任务执行 | Cron 触发时间误差 <1s，客户端正常执行 |
| F3 | 任务启停 | 启停操作实时生效，无需重启客户端 |
| F4 | 手动触发 | 手动触发可立即执行，生成执行记录 |
| F5 | 配置推送 | 配置变更在 3s 内推送到所有在线客户端 |
| F6 | 配置拉取 | 客户端启动后能正确拉取并应用配置 |
| F7 | 分组隔离 | 任务只在指定分组执行，不泄露到其他分组 |
| F8 | 执行监控 | 实时显示执行状态，延迟 <5s |
| F9 | 日志查看 | 可查看完整执行日志，大小超限时提示 |
| F10 | 执行历史 | 可查询任意时间段的执行记录 |

### 11.2 性能验收

| 编号 | 验收项 | 验收标准 |
|-----|-------|---------|
| P1 | 调度精度 | 连续执行 100 次，时间误差标准差 <500ms |
| P2 | 并发执行 | 支持 1000 个任务同时执行 |
| P3 | 推送延迟 | 配置变更到 100 个客户端推送完成 <3s |
| P4 | 存储性能 | 执行记录写入延迟 <100ms |
| P5 | 查询性能 | 执行历史查询响应时间 <500ms |

### 11.3 可靠性验收

| 编号 | 验收项 | 验收标准 |
|-----|-------|---------|
| R1 | 服务重启 | 服务端重启后 30s 内恢复调度 |
| R2 | 客户端重连 | 客户端断线重连后自动获取最新配置 |
| R3 | 失败重试 | 任务失败后按配置自动重试 |
| R4 | 超时控制 | 超时任务自动终止，不影响后续执行 |

---

## 12. 实施计划

### 12.1 开发阶段

| 阶段 | 工作内容 | 交付物 |
|-----|---------|-------|
| Phase 1 | 数据库设计与创建 | DDL 脚本 |
| Phase 2 | Protobuf 协议定义 | proto 文件 |
| Phase 3 | 服务端调度器开发 | 调度模块代码 |
| Phase 4 | 客户端任务引擎开发 | 任务引擎代码 |
| Phase 5 | 配置同步机制开发 | 推送/拉取模块 |
| Phase 6 | Web 管理界面开发 | 前端页面 |
| Phase 7 | 集成测试与联调 | 测试报告 |
| Phase 8 | 文档编写 | API 文档、用户手册 |

### 12.2 里程碑

| 里程碑 | 时间点 | 标志 |
|-------|-------|------|
| M1 | Week 2 | 核心功能开发完成 |
| M2 | Week 3 | 功能测试通过 |
| M3 | Week 4 | 性能测试通过 |
| M4 | Week 5 | 发布 v1.0.0 |

---

## 13. 附录

### 13.1 参考文档

- XXL-JOB 官方文档: https://www.xuxueli.com/xxl-job/
- ElasticJob 文档: https://shardingsphere.apache.org/elasticjob/
- PowerJob 官方文档: https://www.yuque.com/powerjob/guides

### 13.2 Cron 表达式说明

```
格式: 秒 分 时 日 月 周

示例:
0 0 * * *      - 每小时执行
0 2 * * *      - 每天凌晨2点执行
0 */5 * * *    - 每5分钟执行
0 0 * * 1      - 每周一执行
0 0 1 * *      - 每月1号执行
```

### 13.3 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|-----|------|-------|---------|
| V1.0.0 | 2025-01-09 | - | 初稿创建 |
| V1.1.0 | 2025-01-09 | - | 新增客户端本地状态记录功能：支持按天统计、离线同步、本地数据查询 |
| V1.2.0 | 2025-01-09 | - | 新增前端功能需求和非功能需求：任务管理界面、执行监控界面、统计报表界面、系统设置界面 |

---

**文档结束**
