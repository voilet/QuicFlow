# 分布式定时任务系统技术方案

| 文档版本 | V1.1.0 |
|---------|--------|
| 创建日期 | 2025-01-09 |
| 技术负责人 | - |
| 基于文档 | PRD V1.2.0 |

---

## 1. 方案概述

### 1.1 技术选型

| 模块 | 技术选型 | 说明 |
|-----|---------|------|
| 调度引擎 | `github.com/robfig/cron/v3` | Go 语言主流 Cron 调度库 |
| 通信协议 | QUIC (quic-go) | 复用现有 quic-flow 通信层 |
| 数据存储 | MySQL + 本地 JSON 文件 | 服务端 MySQL，客户端本地文件 |
| ORM | GORM | 复用现有数据访问层 |
| 协议序列化 | Protobuf | 复用现有协议定义 |
| Web 框架 | Gin | 复用现有 API 层 |
| 前端框架 | Vue 3 + Element Plus | 复用现有前端技术栈 |

### 1.2 robfig/cron v3 核心特性

```
安装: go get github.com/robfig/cron/v3

核心 API:
- cron.New(): 创建调度器
- cron.AddFunc(spec, func): 添加匿名函数任务
- cron.AddJob(spec, job): 添加 Job 接口任务
- cron.Start(): 启动调度器
- cron.Stop(): 停止调度器

Cron 表达式格式:
- 默认: 分 时 日 月 周 (5 段)
- 秒级: cron.WithSeconds() 选项启用秒 支持
- 预定义: @yearly, @monthly, @weekly, @daily, @hourly

示例:
0 30 * * * *     # 每30分执行 (秒级)
0 2 * * *        # 每天凌晨2点
*/5 * * * *      # 每5分钟
@daily           # 每天午夜
```

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Server 端                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌────────────┐│
│  │   Gin API    │    │  Task Manager│    │ Cron Scheduler│   │  Dispatcher ││
│  │              │    │              │    │   (robfig)    │    │             ││
│  │ /tasks/*     │────│   CRUD       │────│   AddFunc()   │────│   QUIC      ││
│  │ /executions/*│    │   启停控制    │    │   AddJob()    │    │   推送       ││
│  │ /groups/*    │    │   版本管理    │    │               │    │             ││
│  └──────────────┘    └──────────────┘    └──────────────┘    └────────────┘│
│         │                    │                   │                   │      │
│         └────────────────────┴───────────────────┴───────────────────┘      │
│                                     │                                        │
│                              ┌──────▼──────┐                                │
│                              │   GORM DB   │                                │
│                              │   MySQL     │                                │
│                              └─────────────┘                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        │ QUIC Protocol
                                        │
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Client 端                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌────────────┐│
│  │ Task Engine  │    │ LocalStorage │    │  SyncManager │    │ Dispatcher ││
│  │              │    │              │    │              │    │             ││
│  │ 接收配置      │    │ 执行记录     │    │ 离线同步      │    │   QUIC      ││
│  │ 执行任务      │────│ 按天统计     │────│ 状态上报      │────│   上报       ││
│  │ 结果上报      │    │ 7天保留      │    │ 重连补偿      │    │             ││
│  └──────────────┘    └──────────────┘    └──────────────┘    └────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                         Executors Pool                               │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐             │  │
│  │  │  Shell   │  │   HTTP   │  │  Plugin  │  │ Custom   │             │  │
│  │  │ Executor │  │ Executor │  │ Executor │  │ Executor │             │  │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘             │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ~/.quicflow/tasks/                                                         │
│  ├── executions/     # 执行记录                                             │
│  ├── daily_stats/    # 按天统计                                             │
│  └── pending_sync.json # 待同步队列                                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

```
quic-flow/
├── pkg/
│   ├── scheduler/              # 服务端调度模块
│   │   ├── cron.go             # Cron 调度器封装
│   │   ├── task.go             # 任务定义
│   │   ├── manager.go          # 任务管理器
│   │   └── dispatcher.go       # 任务分发器
│   │
│   ├── client/                 # 客户端模块
│   │   ├── task/
│   │   │   ├── engine.go       # 任务引擎
│   │   │   ├── storage.go      # 本地存储
│   │   │   ├── sync.go         # 同步管理器
│   │   │   └── stats.go        # 统计模块
│   │   └── executor/           # 执行器
│   │       ├── shell.go
│   │       ├── http.go
│   │       └── plugin.go
│   │
│   ├── protocol/               # 协议定义（扩展现有）
│   │   └── task.proto
│   │
│   ├── model/                  # 数据模型
│   │   ├── task.go
│   │   ├── execution.go
│   │   └── group.go
│   │
│   ├── api/                    # API 接口
│   │   ├── task.go
│   │   ├── execution.go
│   │   └── group.go
│   │
│   └── store/                  # 数据访问层
│       ├── task_store.go
│       ├── execution_store.go
│       └── group_store.go
│
├── web/src/                    # 前端 (Vue 3 + TypeScript)
│   ├── views/                  # 页面视图
│   │   ├── task/
│   │   │   ├── List.vue        # 任务列表
│   │   │   ├── Form.vue        # 任务表单
│   │   │   ├── Detail.vue      # 任务详情
│   │   │   └── Execution.vue   # 执行监控
│   │   ├── group/
│   │   │   ├── List.vue        # 分组管理
│   │   │   └── Clients.vue     # 分组主机
│   │   ├── dashboard/
│   │   │   └── Index.vue       # 概览仪表盘
│   │   └── settings/
│   │       └── Index.vue       # 系统设置
│   ├── components/             # 公共组件
│   │   ├── task/
│   │   │   ├── TaskCard.vue    # 任务卡片
│   │   │   ├── CronEditor.vue  # Cron 编辑器
│   │   │   └── ExecutionLog.vue # 执行日志
│   │   ├── chart/
│   │   │   ├── LineChart.vue   # 折线图
│   │   │   ├── PieChart.vue    # 饼图
│   │   │   └── BarChart.vue    # 柱状图
│   │   └── common/
│   │       ├── Table.vue       # 通用表格
│   │       ├── Dialog.vue      # 通用弹窗
│   │       └── StatusTag.vue   # 状态标签
│   ├── stores/                 # 状态管理 (Pinia)
│   │   ├── task.ts             # 任务状态
│   │   ├── execution.ts        # 执行状态
│   │   ├── group.ts            # 分组状态
│   │   └── app.ts              # 应用状态
│   ├── api/                    # API 接口
│   │   ├── task.ts             # 任务 API
│   │   ├── execution.ts        # 执行 API
│   │   ├── group.ts            # 分组 API
│   │   └── client.ts           # 客户端 API
│   ├── composables/            # 组合式函数
│   │   ├── useWebSocket.ts     # WebSocket 钩子
│   │   ├── useTable.ts         # 表格钩子
│   │   └── useCron.ts          # Cron 工具
│   ├── utils/                  # 工具函数
│   │   ├── request.ts          # 请求封装
│   │   ├── format.ts           # 格式化
│   │   └── validate.ts         # 校验
│   ├── types/                  # TypeScript 类型
│   │   ├── task.ts
│   │   ├── execution.ts
│   │   └── group.ts
│   ├── styles/                 # 样式
│   │   ├── variables.scss      # 变量
│   │   ├── mixins.scss         # 混合
│   │   └── theme.scss          # 主题
│   ├── locales/                # 国际化
│   │   ├── zh-CN.ts
│   │   └── en-US.ts
│   ├── router/                 # 路由
│   │   └── index.ts
│   ├── App.vue
│   └── main.ts
│
└── scripts/
    └── migration.sql           # 数据库迁移脚本
```

### 2.3 前端架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Browser (前端)                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                         Vue 3 Application                             │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│  │  │   Router    │  │   Pinia     │  │  i18n       │  │   Theme     │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │  │
│  │  ┌──────────────────────────────────────────────────────────────────┐  │  │
│  │  │                         Views                                  │  │  │
│  │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │  │  │
│  │  │  │ Dashboard│  │  Tasks   │  │Execution │  │  Groups  │        │  │  │
│  │  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │  │  │
│  │  │  ┌──────────────────────────────────────────────────────────┐  │  │
│  │  │  │                      Components                          │  │  │
│  │  │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐  │  │  │
│  │  │  │  │  Charts  │  │  Tables  │  │   Forms  │  │  Dialog │  │  │  │
│  │  │  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘  │  │  │
│  │  │  └──────────────────────────────────────────────────────────┘  │  │
│  │  └──────────────────────────────────────────────────────────────────┘  │
│  │  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  │                         Services                                │  │
│  │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐       │  │
│  │  │  │   API    │  │ WebSocket│  │  Utils   │  │ Compose  │       │  │
│  │  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘       │  │
│  │  └──────────────────────────────────────────────────────────────────┘  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    │ HTTP + WebSocket                       │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐  │
│  │                         Nginx (可选)                                 │  │
│  └─────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        │ REST API
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Server (Gin)                                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 数据库设计

### 3.1 ER 图

```
┌──────────────────┐         ┌──────────────────┐         ┌──────────────────┐
│     tb_group     │         │   tb_task_group  │         │     tb_task      │
├──────────────────┤         ├──────────────────┤         ├──────────────────┤
│ id (PK)         │◄────────│ task_id         │─────────││ id (PK)         │
│ name            │         │ group_id        │◄────────││ name            │
│ description     │         │ created_at      │         │ description     │
│ tags            │         └──────────────────┘         │ executor_type   │
│ created_at      │                                    │ executor_config │
│ updated_at      │                                    │ cron_expr       │
└──────────────────┘                                    │ timeout         │
                                                        │ retry_count     │
         │                                               │ status          │
         │                                               │ created_at      │
         │                                               │ updated_at      │
         ▼                                               └─────────────────┘
┌──────────────────┐                                          │
│     tb_client    │                                          │
├──────────────────┤                                          │
│ id (PK)         │                                          │
│ client_id (UK)  │                                          │
│ group_id (FK)   │                                          │
│ hostname        │                                          │
│ ip              │                                          │
│ task_version    │                                          │
│ last_heartbeat  │                                          │
└──────────────────┘                                          │
         │                                                     │
         └─────────────────────────────────────────────────────┘
                                                │
                                                ▼
                                        ┌──────────────────┐
                                        │  tb_execution    │
                                        ├──────────────────┤
                                        │ id (PK)         │
                                        │ task_id (FK)    │
                                        │ client_id (FK)  │
                                        │ group_id        │
                                        │ execution_type  │
                                        │ status          │
                                        │ start_time      │
                                        │ end_time        │
                                        │ duration        │
                                        │ exit_code       │
                                        │ output          │
                                        │ error_msg       │
                                        │ retry_count     │
                                        │ created_at      │
                                        └──────────────────┘
```

### 3.2 建表语句

```sql
-- ============================================================
-- 分布式定时任务系统数据库表结构
-- ============================================================

-- 主机分组表
CREATE TABLE tb_task_group (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    name            VARCHAR(64) NOT NULL COMMENT '分组名称',
    description     VARCHAR(256) COMMENT '分组描述',
    tags            VARCHAR(256) COMMENT '标签(逗号分隔)',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='主机分组表';

-- 定时任务表
CREATE TABLE tb_task (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    name            VARCHAR(128) NOT NULL COMMENT '任务名称',
    description     VARCHAR(512) COMMENT '任务描述',
    executor_type   TINYINT NOT NULL COMMENT '执行器类型:1=Shell,2=HTTP,3=Plugin',
    executor_config TEXT NOT NULL COMMENT '执行器配置(JSON)',
    cron_expr       VARCHAR(64) NOT NULL COMMENT 'Cron表达式',
    timeout         INT NOT NULL DEFAULT 300 COMMENT '超时时间(秒)',
    retry_count     INT NOT NULL DEFAULT 0 COMMENT '重试次数',
    retry_interval  INT NOT NULL DEFAULT 60 COMMENT '重试间隔(秒)',
    concurrency     INT NOT NULL DEFAULT 1 COMMENT '最大并发数',
    status          TINYINT NOT NULL DEFAULT 1 COMMENT '状态:0=禁用,1=启用',
    created_by      VARCHAR(64) COMMENT '创建人',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_name (name),
    KEY idx_status (status),
    KEY idx_updated_at (updated_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='定时任务表';

-- 任务分组关联表
CREATE TABLE tb_task_group_relation (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_id         BIGINT NOT NULL COMMENT '任务ID',
    group_id        BIGINT NOT NULL COMMENT '分组ID',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_task_group (task_id, group_id),
    KEY idx_group_id (group_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务分组关联表';

-- 任务执行记录表
CREATE TABLE tb_execution (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    execution_id    VARCHAR(64) NOT NULL COMMENT '执行实例ID',
    task_id         BIGINT NOT NULL COMMENT '任务ID',
    task_name       VARCHAR(128) COMMENT '任务名称(冗余)',
    client_id       VARCHAR(64) NOT NULL COMMENT '客户端ID',
    group_id        BIGINT COMMENT '分组ID',
    execution_type  TINYINT NOT NULL DEFAULT 1 COMMENT '执行类型:1=定时,2=手动',
    status          TINYINT NOT NULL COMMENT '状态:1=Pending,2=Running,3=Success,4=Failed,5=Timeout,6=Cancelled',
    start_time      DATETIME COMMENT '开始时间',
    end_time        DATETIME COMMENT '结束时间',
    duration        INT COMMENT '执行耗时(毫秒)',
    exit_code       INT COMMENT '退出码',
    output          TEXT COMMENT '执行输出',
    error_msg       TEXT COMMENT '错误信息',
    retry_count     INT NOT NULL DEFAULT 0 COMMENT '重试次数',
    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    KEY idx_execution_id (execution_id),
    KEY idx_task_id (task_id),
    KEY idx_client_id (client_id),
    KEY idx_status (status),
    KEY idx_start_time (start_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务执行记录表';

-- 扩展客户端表
ALTER TABLE tb_client ADD COLUMN task_version BIGINT NOT NULL DEFAULT 0 COMMENT '任务配置版本';
ALTER TABLE tb_client ADD INDEX idx_task_version (task_version);
```

---

## 4. Protobuf 协议定义

### 4.1 任务调度消息

```protobuf
// pkg/protocol/task.proto
syntax = "proto3";

package protocol;
option go_package = "./protocol";

// ============================================================
// 任务调度消息类型
// ============================================================

enum TaskMessageType {
    TASK_UNKNOWN = 0;

    // 配置管理
    TASK_CONFIG_PUSH = 10;       // 服务端推送任务配置
    TASK_CONFIG_PULL = 11;       // 客户端拉取任务配置
    TASK_CONFIG_RESPONSE = 12;   // 任务配置响应

    // 任务执行
    TASK_EXECUTION = 13;         // 任务执行指令
    TASK_PROGRESS = 14;          // 任务执行进度上报
    TASK_RESULT = 15;            // 任务执行结果上报
    TASK_CANCEL = 16;            // 取消任务执行

    // 状态同步
    DAILY_STATS_REPORT = 20;     // 按天统计数据上报
    OFFLINE_SYNC_REQUEST = 21;   // 离线数据同步请求
    OFFLINE_SYNC_RESPONSE = 22;  // 离线数据同步响应
}

// ============================================================
// 配置管理消息
// ============================================================

// 任务配置推送
message TaskConfigPush {
    repeated TaskConfig tasks = 1;
    int64 version = 2;           // 配置版本号
    PushAction action = 3;       // 推送动作
    bool force_sync = 4;         // 强制同步
}

enum PushAction {
    ADD = 0;         // 新增任务
    UPDATE = 1;      // 更新任务
    DELETE = 2;      // 删除任务
    ENABLE = 3;      // 启用任务
    DISABLE = 4;     // 禁用任务
    FULL_SYNC = 5;   // 全量同步
}

// 任务配置
message TaskConfig {
    string id = 1;
    string name = 2;
    ExecutorType executor_type = 3;
    map<string, string> executor_config = 4;
    string cron_expr = 5;
    int32 timeout = 6;
    int32 retry_count = 7;
    int32 retry_interval = 8;
    bool enabled = 9;
}

enum ExecutorType {
    SHELL = 0;
    HTTP = 1;
    PLUGIN = 2;
}

// 任务配置拉取请求
message TaskConfigPull {
    string client_id = 1;
    string group_id = 2;
    int64 local_version = 3;     // 本地版本号
}

// 任务配置响应
message TaskConfigResponse {
    repeated TaskConfig tasks = 1;
    int64 version = 2;
    bool full_sync = 3;          // 是否全量同步
}

// ============================================================
// 任务执行消息
// ============================================================

// 任务执行指令
message TaskExecution {
    string execution_id = 1;     // 执行实例ID
    string task_id = 2;          // 任务ID
    string task_name = 3;        // 任务名称
    ExecutorType executor_type = 4;
    map<string, string> executor_config = 5;
    int32 timeout = 6;
    map<string, string> params = 7;  // 动态参数
    int64 scheduled_time = 8;    // 调度时间戳
    int32 retry_count = 9;       // 当前重试次数
}

// 任务执行进度
message TaskProgress {
    string execution_id = 1;
    string task_id = 2;
    ExecutionStatus status = 3;
    int64 started_at = 4;
    string output = 5;           // 增量输出
    int32 output_offset = 6;     // 输出偏移量
}

enum ExecutionStatus {
    PENDING = 0;
    RUNNING = 1;
    SUCCESS = 2;
    FAILURE = 3;
    TIMEOUT = 4;
    CANCELLED = 5;
}

// 任务执行结果
message TaskResult {
    string execution_id = 1;
    string task_id = 2;
    ExecutionStatus status = 3;
    int64 started_at = 4;
    int64 finished_at = 5;
    int32 exit_code = 6;
    string output = 7;           // 完整输出
    string error = 8;            // 错误信息
    int32 retry_count = 9;
    int32 duration_ms = 10;      // 执行耗时
}

// ============================================================
// 状态同步消息
// ============================================================

// 按天统计数据上报
message DailyStatsReport {
    string client_id = 1;
    string date = 2;             // YYYY-MM-DD
    repeated TaskStats task_stats = 3;
    int64 report_time = 4;
}

message TaskStats {
    string task_id = 1;
    string task_name = 2;
    int32 success_count = 3;
    int32 failure_count = 4;
    int32 timeout_count = 5;
    int32 cancelled_count = 6;
    int64 total_duration_ms = 7;
    int32 max_duration_ms = 8;
    int32 min_duration_ms = 9;
    map<string, int32> hourly_distribution = 10;  // 小时分布
}

// 离线数据同步请求
message OfflineSyncRequest {
    string client_id = 1;
    int64 last_sync_time = 2;    // 上次成功同步时间
    int32 record_count = 3;      // 待同步记录数
}

// 离线数据同步响应
message OfflineSyncResponse {
    bool success = 1;
    string message = 2;
    int64 synced_count = 3;     // 成功同步的记录数
    int64 server_time = 4;       // 服务端时间
}
```

---

## 5. 核心模块实现

### 5.1 服务端 Cron 调度器

```go
// pkg/scheduler/cron.go
package scheduler

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/robfig/cron/v3"
    "go.uber.org/zap"
)

// CronScheduler 基于 robfig/cron 的调度器
type CronScheduler struct {
    cron           *cron.Cron
    logger         *zap.Logger
    taskDispatcher *TaskDispatcher
    jobRegistry    map[cron.EntryID]string  // EntryID -> TaskID
    registryMu     sync.RWMutex
    ctx            context.Context
    cancel         context.CancelFunc
}

// Task 定义任务接口
type Task interface {
    GetID() string
    GetName() string
    GetCronExpr() string
    IsEnabled() bool
    Execute(ctx context.Context) error
}

// NewCronScheduler 创建调度器
func NewCronScheduler(logger *zap.Logger, dispatcher *TaskDispatcher) *CronScheduler {
    ctx, cancel := context.WithCancel(context.Background())

    // 使用秒级精度，支持 6 段 Cron 表达式
    // 自定义日志记录器
    c := cron.New(
        cron.WithSeconds(),           // 支持秒级调度
        cron.WithLogger(cron.VerbosePrintfLogger(logger.Sugar())),
    )

    return &CronScheduler{
        cron:           c,
        logger:         logger,
        taskDispatcher: dispatcher,
        jobRegistry:    make(map[cron.EntryID]string),
        ctx:            ctx,
        cancel:         cancel,
    }
}

// Start 启动调度器
func (s *CronScheduler) Start() {
    s.cron.Start()
    s.logger.Info("Cron scheduler started")
}

// Stop 停止调度器
func (s *CronScheduler) Stop() {
    s.cancel()
    ctx := s.cron.Stop()

    select {
    case <-ctx.Done():
        s.logger.Info("Cron scheduler stopped gracefully")
    case <-time.After(10 * time.Second):
        s.logger.Warn("Cron scheduler stop timeout")
    }
}

// AddTask 添加任务到调度器
func (s *CronScheduler) AddTask(task Task) (cron.EntryID, error) {
    if !task.IsEnabled() {
        return 0, fmt.Errorf("task %s is disabled", task.GetID())
    }

    // 验证 Cron 表达式
    if err := s.validateCronExpr(task.GetCronExpr()); err != nil {
        return 0, fmt.Errorf("invalid cron expression: %w", err)
    }

    // 创建 Job
    job := s.createJob(task)

    // 添加到调度器
    entryID, err := s.cron.AddFunc(task.GetCronExpr(), job)
    if err != nil {
        return 0, fmt.Errorf("failed to add cron job: %w", err)
    }

    // 注册
    s.registryMu.Lock()
    s.jobRegistry[entryID] = task.GetID()
    s.registryMu.Unlock()

    s.logger.Info("Task added to scheduler",
        zap.String("task_id", task.GetID()),
        zap.String("task_name", task.GetName()),
        zap.String("cron_expr", task.GetCronExpr()),
    )

    return entryID, nil
}

// RemoveTask 从调度器移除任务
func (s *CronScheduler) RemoveTask(taskID string) error {
    s.registryMu.Lock()
    defer s.registryMu.Unlock()

    // 查找 EntryID
    var targetID cron.EntryID
    for entryID, id := range s.jobRegistry {
        if id == taskID {
            targetID = entryID
            delete(s.jobRegistry, entryID)
            break
        }
    }

    if targetID == 0 {
        return fmt.Errorf("task %s not found in registry", taskID)
    }

    s.cron.Remove(targetID)
    s.logger.Info("Task removed from scheduler", zap.String("task_id", taskID))

    return nil
}

// UpdateTask 更新任务
func (s *CronScheduler) UpdateTask(task Task) error {
    // 先移除旧任务
    s.RemoveTask(task.GetID())

    // 如果启用则重新添加
    if task.IsEnabled() {
        _, err := s.AddTask(task)
        return err
    }

    return nil
}

// createJob 创建执行函数
func (s *CronScheduler) createJob(task Task) func() {
    return func() {
        // 在独立 goroutine 中执行，避免阻塞调度器
        go func() {
            defer func() {
                if r := recover(); r != nil {
                    s.logger.Error("Task panic",
                        zap.String("task_id", task.GetID()),
                        zap.Any("panic", r),
                    )
                }
            }()

            // 执行任务分发
            if err := s.taskDispatcher.Dispatch(s.ctx, task); err != nil {
                s.logger.Error("Failed to dispatch task",
                    zap.String("task_id", task.GetID()),
                    zap.Error(err),
                )
            }
        }()
    }
}

// validateCronExpr 验证 Cron 表达式
func (s *CronScheduler) validateCronExpr(expr string) error {
    // 使用 cron 解析器验证
    _, err := cron.ParseStandard(expr)
    return err
}

// GetNextRunTime 获取任务下次执行时间
func (s *CronScheduler) GetNextRunTime(taskID string) (time.Time, error) {
    s.registryMu.RLock()
    defer s.registryMu.RUnlock()

    for entryID, id := range s.jobRegistry {
        if id == taskID {
            entry := s.cron.Entry(entryID)
            if entry.ID == 0 {
                return time.Time{}, fmt.Errorf("entry not found")
            }
            return entry.Next, nil
        }
    }

    return time.Time{}, fmt.Errorf("task not found")
}

// GetAllEntries 获取所有任务条目
func (s *CronScheduler) GetAllEntries() []cron.Entry {
    return s.cron.Entries()
}

// GetStats 获取调度器统计信息
func (s *CronScheduler) GetStats() map[string]interface{} {
    entries := s.cron.Entries()

    stats := map[string]interface{}{
        "total_jobs":    len(entries),
        "running":       s.cron.Entry(len(entries) - 1).ID > 0,
        "registry_size": len(s.jobRegistry),
    }

    return stats
}
```

### 5.2 任务分发器

```go
// pkg/scheduler/dispatcher.go
package scheduler

import (
    "context"
    "fmt"
    "sync"

    "github.com/quic-flow/quic-flow/pkg/dispatcher"
    "github.com/quic-flow/quic-flow/pkg/model"
    "github.com/quic-flow/quic-flow/pkg/protocol"
    "github.com/quic-flow/quic-flow/pkg/session"
    "go.uber.org/zap"
)

// TaskDispatcher 任务分发器
type TaskDispatcher struct {
    logger      *zap.Logger
    dispatcher  *dispatcher.Dispatcher
    sessionMgr  *session.Manager
    taskStore   TaskStore
}

// NewTaskDispatcher 创建任务分发器
func NewTaskDispatcher(
    logger *zap.Logger,
    dp *dispatcher.Dispatcher,
    sm *session.Manager,
    ts TaskStore,
) *TaskDispatcher {
    return &TaskDispatcher{
        logger:     logger,
        dispatcher: dp,
        sessionMgr: sm,
        taskStore:  ts,
    }
}

// Dispatch 分发任务到目标客户端
func (d *TaskDispatcher) Dispatch(ctx context.Context, task Task) error {
    // 获取任务配置
    taskID := task.GetID()
    taskModel, err := d.taskStore.GetByID(ctx, taskID)
    if err != nil {
        return fmt.Errorf("failed to get task: %w", err)
    }

    // 获取目标分组
    groupIDs, err := d.taskStore.GetGroupIDs(ctx, taskID)
    if err != nil {
        return fmt.Errorf("failed to get task groups: %w", err)
    }

    // 获取分组内的所有在线客户端
    clients := d.getTargetClients(groupIDs)
    if len(clients) == 0 {
        d.logger.Warn("No online clients for task",
            zap.String("task_id", taskID),
            zap.Int64s("group_ids", groupIDs),
        )
        return nil
    }

    // 并发分发
    var wg sync.WaitGroup
    errCh := make(chan error, len(clients))

    for _, client := range clients {
        wg.Add(1)
        go func(c *session.Client) {
            defer wg.Done()

            if err := d.dispatchToClient(ctx, c, taskModel); err != nil {
                d.logger.Error("Failed to dispatch to client",
                    zap.String("task_id", taskID),
                    zap.String("client_id", c.ID),
                    zap.Error(err),
                )
                errCh <- err
            }
        }(client)
    }

    wg.Wait()
    close(errCh)

    // 收集错误
    var errors []error
    for err := range errCh {
        errors = append(errors, err)
    }

    if len(errors) > 0 {
        return fmt.Errorf("dispatch failed for %d clients", len(errors))
    }

    d.logger.Info("Task dispatched successfully",
        zap.String("task_id", taskID),
        zap.Int("client_count", len(clients)),
    )

    return nil
}

// dispatchToClient 分发到单个客户端
func (d *TaskDispatcher) dispatchToClient(ctx context.Context, client *session.Client, task *model.Task) error {
    // 生成执行实例ID
    executionID := d.generateExecutionID(task.ID, client.ID)

    // 构造执行消息
    execMsg := &protocol.TaskExecution{
        ExecutionId: executionID,
        TaskId:      task.ID,
        TaskName:    task.Name,
        ExecutorType: protocol.ExecutorType(task.ExecutorType),
        ExecutorConfig: parseExecutorConfig(task.ExecutorConfig),
        Timeout:     int32(task.Timeout),
        ScheduledTime: task.NextRunTime.Unix(),
    }

    // 发送消息
    if err := d.dispatcher.SendToClient(ctx, client.ID, protocol.TASK_EXECUTION, execMsg); err != nil {
        return fmt.Errorf("failed to send execution message: %w", err)
    }

    // 记录执行实例
    if err := d.recordExecution(executionID, task, client.ID); err != nil {
        d.logger.Error("Failed to record execution",
            zap.String("execution_id", executionID),
            zap.Error(err),
        )
    }

    return nil
}

// getTargetClients 获取目标客户端列表
func (d *TaskDispatcher) getTargetClients(groupIDs []int64) []*session.Client {
    var clients []*session.Client

    for _, groupID := range groupIDs {
        groupClients := d.sessionMgr.GetClientsByGroup(groupID)
        clients = append(clients, groupClients...)
    }

    return clients
}

// generateExecutionID 生成执行实例ID
func (d *TaskDispatcher) generateExecutionID(taskID string, clientID string) string {
    return fmt.Sprintf("%s-%s-%d", taskID, clientID, time.Now().UnixNano())
}

// recordExecution 记录执行实例
func (d *TaskDispatcher) recordExecution(executionID string, task *model.Task, clientID string) error {
    execution := &model.Execution{
        ExecutionID:   executionID,
        TaskID:        task.ID,
        TaskName:      task.Name,
        ClientID:      clientID,
        GroupID:       task.GroupID,
        ExecutionType: model.ExecutionTypeScheduled,
        Status:        model.ExecutionStatusPending,
        CreatedAt:     time.Now(),
    }

    return d.taskStore.CreateExecution(context.Background(), execution)
}
```

### 5.3 任务管理器

```go
// pkg/scheduler/manager.go
package scheduler

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/quic-flow/quic-flow/pkg/model"
    "github.com/quic-flow/quic-flow/pkg/store"
    "go.uber.org/zap"
)

// TaskManager 任务管理器
type TaskManager struct {
    logger         *zap.Logger
    cron           *CronScheduler
    dispatcher     *TaskDispatcher
    taskStore      store.TaskStore
    configVersion  int64
    versionSubs    []chan int64
    subsMu         sync.RWMutex
}

// NewTaskManager 创建任务管理器
func NewTaskManager(
    logger *zap.Logger,
    cron *CronScheduler,
    dispatcher *TaskDispatcher,
    taskStore store.TaskStore,
) *TaskManager {
    return &TaskManager{
        logger:      logger,
        cron:        cron,
        dispatcher:  dispatcher,
        taskStore:   taskStore,
        versionSubs: make([]chan int64, 0),
    }
}

// Initialize 初始化任务管理器
func (m *TaskManager) Initialize(ctx context.Context) error {
    // 加载所有启用的任务
    tasks, err := m.taskStore.ListEnabled(ctx)
    if err != nil {
        return fmt.Errorf("failed to load tasks: %w", err)
    }

    // 添加到调度器
    for _, task := range tasks {
        if _, err := m.cron.AddTask(task); err != nil {
            m.logger.Error("Failed to add task to scheduler",
                zap.String("task_id", task.ID),
                zap.Error(err),
            )
            continue
        }
    }

    m.logger.Info("Task manager initialized",
        zap.Int("total_tasks", len(tasks)),
    )

    return nil
}

// CreateTask 创建任务
func (m *TaskManager) CreateTask(ctx context.Context, req *CreateTaskRequest) (*model.Task, error) {
    task := &model.Task{
        ID:              generateTaskID(),
        Name:            req.Name,
        Description:     req.Description,
        ExecutorType:    req.ExecutorType,
        ExecutorConfig:  req.ExecutorConfig,
        CronExpr:        req.CronExpr,
        Timeout:         req.Timeout,
        RetryCount:      req.RetryCount,
        RetryInterval:   req.RetryInterval,
        Concurrency:     req.Concurrency,
        Status:          1, // 默认启用
        CreatedBy:       req.CreatedBy,
        CreatedAt:       time.Now(),
        UpdatedAt:       time.Now(),
    }

    // 保存到数据库
    if err := m.taskStore.Create(ctx, task); err != nil {
        return nil, err
    }

    // 绑定分组
    for _, groupID := range req.GroupIDs {
        if err := m.taskStore.BindGroup(ctx, task.ID, groupID); err != nil {
            m.logger.Error("Failed to bind group",
                zap.String("task_id", task.ID),
                zap.Int64("group_id", groupID),
                zap.Error(err),
            )
        }
    }

    // 添加到调度器
    if _, err := m.cron.AddTask(task); err != nil {
        return nil, err
    }

    // 递增版本号
    m.incrementVersion()

    // 推送配置到客户端
    m.pushTaskConfig(task, PushAction_ADD)

    return task, nil
}

// UpdateTask 更新任务
func (m *TaskManager) UpdateTask(ctx context.Context, req *UpdateTaskRequest) error {
    task, err := m.taskStore.GetByID(ctx, req.TaskID)
    if err != nil {
        return err
    }

    // 更新字段
    if req.Name != nil {
        task.Name = *req.Name
    }
    if req.Description != nil {
        task.Description = *req.Description
    }
    if req.ExecutorConfig != nil {
        task.ExecutorConfig = *req.ExecutorConfig
    }
    if req.CronExpr != nil {
        task.CronExpr = *req.CronExpr
    }
    if req.Timeout != nil {
        task.Timeout = *req.Timeout
    }
    task.UpdatedAt = time.Now()

    // 保存到数据库
    if err := m.taskStore.Update(ctx, task); err != nil {
        return err
    }

    // 更新调度器
    if err := m.cron.UpdateTask(task); err != nil {
        return err
    }

    // 递增版本号
    m.incrementVersion()

    // 推送配置更新
    m.pushTaskConfig(task, PushAction_UPDATE)

    return nil
}

// EnableTask 启用任务
func (m *TaskManager) EnableTask(ctx context.Context, taskID string) error {
    task, err := m.taskStore.GetByID(ctx, taskID)
    if err != nil {
        return err
    }

    task.Status = 1
    task.UpdatedAt = time.Now()

    if err := m.taskStore.Update(ctx, task); err != nil {
        return err
    }

    if _, err := m.cron.AddTask(task); err != nil {
        return err
    }

    m.incrementVersion()
    m.pushTaskConfig(task, PushAction_ENABLE)

    return nil
}

// DisableTask 禁用任务
func (m *TaskManager) DisableTask(ctx context.Context, taskID string) error {
    task, err := m.taskStore.GetByID(ctx, taskID)
    if err != nil {
        return err
    }

    task.Status = 0
    task.UpdatedAt = time.Now()

    if err := m.taskStore.Update(ctx, task); err != nil {
        return err
    }

    if err := m.cron.RemoveTask(taskID); err != nil {
        return err
    }

    m.incrementVersion()
    m.pushTaskConfig(task, PushAction_DISABLE)

    return nil
}

// DeleteTask 删除任务
func (m *TaskManager) DeleteTask(ctx context.Context, taskID string) error {
    // 先禁用
    if err := m.DisableTask(ctx, taskID); err != nil {
        return err
    }

    // 删除数据库记录
    if err := m.taskStore.Delete(ctx, taskID); err != nil {
        return err
    }

    m.incrementVersion()

    return nil
}

// TriggerTask 手动触发任务
func (m *TaskManager) TriggerTask(ctx context.Context, taskID string, params map[string]string) (string, error) {
    task, err := m.taskStore.GetByID(ctx, taskID)
    if err != nil {
        return "", err
    }

    // 立即分发（不经过 Cron）
    if err := m.dispatcher.Dispatch(ctx, task); err != nil {
        return "", err
    }

    return "ok", nil
}

// GetNextRunTime 获取任务下次执行时间
func (m *TaskManager) GetNextRunTime(taskID string) (time.Time, error) {
    return m.cron.GetNextRunTime(taskID)
}

// incrementVersion 递增配置版本号
func (m *TaskManager) incrementVersion() {
    m.configVersion++
    m.notifyVersionChange(m.configVersion)
}

// GetVersion 获取当前配置版本
func (m *TaskManager) GetVersion() int64 {
    return m.configVersion
}

// Subscribe 版本订阅
func (m *TaskManager) Subscribe() chan int64 {
    m.subsMu.Lock()
    defer m.subsMu.Unlock()

    ch := make(chan int64, 1)
    m.versionSubs = append(m.versionSubs, ch)

    return ch
}

// notifyVersionChange 通知版本变更
func (m *TaskManager) notifyVersionChange(version int64) {
    m.subsMu.RLock()
    defer m.subsMu.RUnlock()

    for _, ch := range m.versionSubs {
        select {
        case ch <- version:
        default:
        }
    }
}

// pushTaskConfig 推送任务配置到客户端
func (m *TaskManager) pushTaskConfig(task *model.Task, action PushAction) {
    // 获取任务分组
    groupIDs, err := m.taskStore.GetGroupIDs(context.Background(), task.ID)
    if err != nil {
        m.logger.Error("Failed to get task groups for push",
            zap.String("task_id", task.ID),
            zap.Error(err),
        )
        return
    }

    // 构造推送消息
    pushMsg := &protocol.TaskConfigPush{
        Tasks: []*protocol.TaskConfig{
            {
                Id:            task.ID,
                Name:          task.Name,
                ExecutorType:  protocol.ExecutorType(task.ExecutorType),
                ExecutorConfig: parseExecutorConfig(task.ExecutorConfig),
                CronExpr:      task.CronExpr,
                Timeout:       int32(task.Timeout),
                RetryCount:    int32(task.RetryCount),
                RetryInterval: int32(task.RetryInterval),
                Enabled:       task.Status == 1,
            },
        },
        Version: m.configVersion,
        Action:  action,
    }

    // 推送到目标分组客户端
    m.dispatcher.PushToGroups(groupIDs, pushMsg)
}
```

### 5.4 客户端任务引擎

```go
// pkg/client/task/engine.go
package task

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/quic-flow/quic-flow/pkg/client/executor"
    "github.com/quic-flow/quic-flow/pkg/dispatcher"
    "github.com/quic-flow/quic-flow/pkg/protocol"
    "github.com/quic-flow/quic-flow/pkg/session"
    "go.uber.org/zap"
)

// Engine 客户端任务引擎
type Engine struct {
    logger         *zap.Logger
    clientID       string
    groupID        string
    dispatcher     *dispatcher.Dispatcher
    storage        *LocalStorage
    syncMgr        *SyncManager
    executorPool   *executor.Pool
    localTasks     map[string]*LocalTask
    runningTasks   map[string]context.CancelFunc
    mu             sync.RWMutex
    ctx            context.Context
    cancel         context.CancelFunc
}

// LocalTask 本地任务
type LocalTask struct {
    config      *protocol.TaskConfig
    enabled     bool
    addedAt     time.Time
}

// NewEngine 创建任务引擎
func NewEngine(
    logger *zap.Logger,
    clientID string,
    groupID string,
    dp *dispatcher.Dispatcher,
    storage *LocalStorage,
) *Engine {
    ctx, cancel := context.WithCancel(context.Background())

    return &Engine{
        logger:       logger,
        clientID:     clientID,
        groupID:      groupID,
        dispatcher:   dp,
        storage:      storage,
        executorPool: executor.NewPool(),
        localTasks:   make(map[string]*LocalTask),
        runningTasks: make(map[string]context.CancelFunc),
        ctx:          ctx,
        cancel:       cancel,
    }
}

// Start 启动任务引擎
func (e *Engine) Start() error {
    // 注册消息处理器
    e.dispatcher.RegisterHandler(protocol.TASK_CONFIG_PUSH, e.handleConfigPush)
    e.dispatcher.RegisterHandler(protocol.TASK_EXECUTION, e.handleExecution)
    e.dispatcher.RegisterHandler(protocol.TASK_CANCEL, e.handleCancel)

    // 拉取初始配置
    if err := e.pullConfig(); err != nil {
        e.logger.Error("Failed to pull initial config", zap.Error(err))
    }

    // 启动同步管理器
    e.syncMgr = NewSyncManager(e.storage, e.dispatcher, e.clientID)
    e.syncMgr.Start(e.ctx)

    e.logger.Info("Task engine started", zap.String("client_id", e.clientID))

    return nil
}

// Stop 停止任务引擎
func (e *Engine) Stop() {
    e.cancel()

    // 取消所有运行中的任务
    e.mu.Lock()
    for taskID, cancel := range e.runningTasks {
        e.logger.Info("Cancelling task", zap.String("task_id", taskID))
        cancel()
    }
    e.runningTasks = nil
    e.mu.Unlock()

    // 停止同步管理器
    if e.syncMgr != nil {
        e.syncMgr.Stop()
    }

    e.logger.Info("Task engine stopped")
}

// handleConfigPush 处理配置推送
func (e *Engine) handleConfigPush(ctx context.Context, msg *protocol.Message) error {
    push, ok := msg.Body.(*protocol.TaskConfigPush)
    if !ok {
        return fmt.Errorf("invalid message type")
    }

    e.mu.Lock()
    defer e.mu.Unlock()

    for _, taskConfig := range push.Tasks {
        switch push.Action {
        case protocol.PushAction_ADD, protocol.PushAction_UPDATE:
            e.localTasks[taskConfig.Id] = &LocalTask{
                config:  taskConfig,
                enabled: taskConfig.Enabled,
                addedAt: time.Now(),
            }
            e.logger.Info("Task added/updated",
                zap.String("task_id", taskConfig.Id),
                zap.String("action", push.Action.String()),
            )

        case protocol.PushAction_DELETE:
            delete(e.localTasks, taskConfig.Id)
            e.logger.Info("Task deleted", zap.String("task_id", taskConfig.Id))

        case protocol.PushAction_ENABLE:
            if task, exists := e.localTasks[taskConfig.Id]; exists {
                task.enabled = true
            }

        case protocol.PushAction_DISABLE:
            if task, exists := e.localTasks[taskConfig.Id]; exists {
                task.enabled = false
            }
        }
    }

    return nil
}

// handleExecution 处理任务执行指令
func (e *Engine) handleExecution(ctx context.Context, msg *protocol.Message) error {
    exec, ok := msg.Body.(*protocol.TaskExecution)
    if !ok {
        return fmt.Errorf("invalid message type")
    }

    // 检查任务是否存在且启用
    e.mu.RLock()
    localTask, exists := e.localTasks[exec.TaskId]
    if !exists || !localTask.enabled {
        e.mu.RUnlock()
        return fmt.Errorf("task not found or disabled: %s", exec.TaskId)
    }
    e.mu.RUnlock()

    // 创建执行上下文
    execCtx, cancel := context.WithTimeout(e.ctx, time.Duration(exec.Timeout)*time.Second)

    e.mu.Lock()
    e.runningTasks[exec.ExecutionId] = cancel
    e.mu.Unlock()

    // 异步执行
    go e.execute(execCtx, exec, localTask.config)

    return nil
}

// execute 执行任务
func (e *Engine) execute(ctx context.Context, exec *protocol.TaskExecution, config *protocol.TaskConfig) {
    executionID := exec.ExecutionId
    startTime := time.Now()

    // 上报开始
    e.reportProgress(&protocol.TaskProgress{
        ExecutionId: executionID,
        TaskId:      exec.TaskId,
        Status:      protocol.ExecutionStatus_RUNNING,
        StartedAt:   startTime.Unix(),
    })

    // 获取执行器
    execImpl, err := e.executorPool.GetExecutor(config.ExecutorType)
    if err != nil {
        e.handleExecutionError(executionID, exec.TaskId, err)
        return
    }

    // 执行任务
    result := execImpl.Execute(ctx, &executor.Context{
        ExecutionID: executionID,
        TaskID:      exec.TaskId,
        Config:      config.ExecutorConfig,
        Params:      exec.Params,
    })

    duration := time.Since(startTime)

    // 构造执行记录
    record := &ExecutionRecord{
        ExecutionID: executionID,
        TaskID:      exec.TaskId,
        TaskName:    exec.TaskName,
        Status:      result.Status,
        StartTime:   startTime,
        EndTime:     startTime.Add(duration),
        DurationMs:  duration.Milliseconds(),
        ExitCode:    result.ExitCode,
        Synced:      false,
    }

    // 保存到本地存储
    if err := e.storage.SaveExecution(record); err != nil {
        e.logger.Error("Failed to save execution record",
            zap.String("execution_id", executionID),
            zap.Error(err),
        )
    }

    // 更新按天统计
    if err := e.storage.UpdateDailyStats(record); err != nil {
        e.logger.Error("Failed to update daily stats",
            zap.String("execution_id", executionID),
            zap.Error(err),
        )
    }

    // 上报结果
    e.reportResult(&protocol.TaskResult{
        ExecutionId: executionID,
        TaskId:      exec.TaskId,
        Status:      result.Status,
        StartedAt:   startTime.Unix(),
        FinishedAt:  startTime.Add(duration).Unix(),
        ExitCode:    int32(result.ExitCode),
        Output:      result.Output,
        Error:       result.Error,
        DurationMs:  int32(duration.Milliseconds()),
    })

    // 清理运行中的任务
    e.mu.Lock()
    delete(e.runningTasks, executionID)
    e.mu.Unlock()
}

// handleExecutionError 处理执行错误
func (e *Engine) handleExecutionError(executionID, taskID string, err error) {
    e.logger.Error("Execution error",
        zap.String("execution_id", executionID),
        zap.String("task_id", taskID),
        zap.Error(err),
    )

    e.reportResult(&protocol.TaskResult{
        ExecutionId: executionID,
        TaskId:      taskID,
        Status:      protocol.ExecutionStatus_FAILURE,
        Error:       err.Error(),
    })
}

// reportProgress 上报执行进度
func (e *Engine) reportProgress(progress *protocol.TaskProgress) {
    if err := e.dispatcher.SendToServer(protocol.TASK_PROGRESS, progress); err != nil {
        e.logger.Error("Failed to report progress",
            zap.String("execution_id", progress.ExecutionId),
            zap.Error(err),
        )
    }
}

// reportResult 上报执行结果
func (e *Engine) reportResult(result *protocol.TaskResult) {
    if err := e.dispatcher.SendToServer(protocol.TASK_RESULT, result); err != nil {
        e.logger.Error("Failed to report result",
            zap.String("execution_id", result.ExecutionId),
            zap.Error(err),
        )
    }
}

// pullConfig 拉取配置
func (e *Engine) pullConfig() error {
    req := &protocol.TaskConfigPull{
        ClientId:      e.clientID,
        GroupId:       e.groupID,
        LocalVersion:  e.storage.GetLastSyncVersion(),
    }

    resp, err := e.dispatcher.Request(protocol.TASK_CONFIG_PULL, req, 10*time.Second)
    if err != nil {
        return err
    }

    configResp, ok := resp.(*protocol.TaskConfigResponse)
    if !ok {
        return fmt.Errorf("invalid response type")
    }

    // 应用配置
    push := &protocol.TaskConfigPush{
        Tasks:   configResp.Tasks,
        Version: configResp.Version,
        Action:  protocol.PushAction_FULL_SYNC,
    }

    return e.handleConfigPush(context.Background(), &protocol.Message{
        Type: protocol.TASK_CONFIG_PUSH,
        Body: push,
    })
}
```

### 5.5 执行器实现

```go
// pkg/client/executor/shell.go
package executor

import (
    "bytes"
    "context"
    "fmt"
    "os/exec"
    "strings"
    "syscall"
    "time"
)

// ShellExecutor Shell 命令执行器
type ShellExecutor struct {
    timeout time.Duration
}

// NewShellExecutor 创建 Shell 执行器
func NewShellExecutor() *ShellExecutor {
    return &ShellExecutor{}
}

// Execute 执行 Shell 命令
func (e *ShellExecutor) Execute(ctx context.Context, execCtx *Context) *Result {
    // 解析配置
    command, ok := execCtx.Config["command"]
    if !ok {
        return &Result{
            Status:   ExecutionStatus_FAILURE,
            ExitCode: -1,
            Error:    "command not found in config",
        }
    }

    workDir := execCtx.Config["work_dir"]

    // 创建命令
    cmd := exec.Command("bash", "-c", command)
    if workDir != "" {
        cmd.Dir = workDir
    }

    // 设置环境变量
    if envVars := execCtx.Config["env"]; envVars != "" {
        cmd.Env = append(cmd.Env, strings.Split(envVars, " ")...)
    }

    // 执行命令
    var stdout, stderr bytes.Buffer
    cmd.Stdout = &stdout
    cmd.Stderr = &stderr

    startTime := time.Now()
    err := cmd.Run()
    duration := time.Since(startTime)

    // 构造结果
    result := &Result{
        Status:      ExecutionStatus_SUCCESS,
        ExitCode:    0,
        Output:      stdout.String(),
        Error:       stderr.String(),
        DurationMs:  duration.Milliseconds(),
    }

    if err != nil {
        result.Status = ExecutionStatus_FAILURE

        if exitErr, ok := err.(*exec.ExitError); ok {
            if status, ok := exitErr.Sys().(syscall.WaitStatus); ok {
                result.ExitCode = status.ExitStatus()
            }
        } else if ctx.Err() == context.DeadlineExceeded {
            result.Status = ExecutionStatus_TIMEOUT
        }
    }

    return result
}
```

```go
// pkg/client/executor/http.go
package executor

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// HTTPExecutor HTTP 请求执行器
type HTTPExecutor struct {
    client *http.Client
}

// NewHTTPExecutor 创建 HTTP 执行器
func NewHTTPExecutor() *HTTPExecutor {
    return &HTTPExecutor{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

// Execute 执行 HTTP 请求
func (e *HTTPExecutor) Execute(ctx context.Context, execCtx *Context) *Result {
    // 解析配置
    url, ok := execCtx.Config["url"]
    if !ok {
        return &Result{
            Status:   ExecutionStatus_FAILURE,
            ExitCode: -1,
            Error:    "url not found in config",
        }
    }

    method := execCtx.Config["method"]
    if method == "" {
        method = "GET"
    }

    // 创建请求
    var body io.Reader
    if bodyStr := execCtx.Config["body"]; bodyStr != "" {
        body = bytes.NewBufferString(bodyStr)
    }

    req, err := http.NewRequestWithContext(ctx, method, url, body)
    if err != nil {
        return &Result{
            Status:   ExecutionStatus_FAILURE,
            ExitCode: -1,
            Error:    err.Error(),
        }
    }

    // 设置 Headers
    if headers := execCtx.Config["headers"]; headers != "" {
        var headerMap map[string]string
        if err := json.Unmarshal([]byte(headers), &headerMap); err == nil {
            for k, v := range headerMap {
                req.Header.Set(k, v)
            }
        }
    }

    // 执行请求
    startTime := time.Now()
    resp, err := e.client.Do(req)
    duration := time.Since(startTime)

    if err != nil {
        return &Result{
            Status:     ExecutionStatus_FAILURE,
            ExitCode:   -1,
            Error:      err.Error(),
            DurationMs: duration.Milliseconds(),
        }
    }
    defer resp.Body.Close()

    // 读取响应
    respBody, _ := io.ReadAll(resp.Body)

    // 判断状态
    status := ExecutionStatus_SUCCESS
    exitCode := 0
    if resp.StatusCode >= 400 {
        status = ExecutionStatus_FAILURE
        exitCode = resp.StatusCode
    }

    return &Result{
        Status:     status,
        ExitCode:   exitCode,
        Output:     string(respBody),
        DurationMs: duration.Milliseconds(),
    }
}
```

```go
// pkg/client/executor/pool.go
package executor

import (
    "fmt"
)

// Pool 执行器池
type Pool struct {
    executors map[ExecutorType]Executor
}

// NewPool 创建执行器池
func NewPool() *Pool {
    pool := &Pool{
        executors: make(map[ExecutorType]Executor),
    }

    // 注册默认执行器
    pool.Register(ExecutorType_SHELL, NewShellExecutor())
    pool.Register(ExecutorType_HTTP, NewHTTPExecutor())

    return pool
}

// Register 注册执行器
func (p *Pool) Register(execType ExecutorType, executor Executor) {
    p.executors[execType] = executor
}

// GetExecutor 获取执行器
func (p *Pool) GetExecutor(execType ExecutorType) (Executor, error) {
    executor, ok := p.executors[execType]
    if !ok {
        return nil, fmt.Errorf("executor not found: %v", execType)
    }
    return executor, nil
}
```

---

## 6. API 接口实现

```go
// pkg/api/task.go
package api

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "github.com/quic-flow/quic-flow/pkg/model"
    "github.com/quic-flow/quic-flow/pkg/scheduler"
)

// TaskAPI 任务 API
type TaskAPI struct {
    taskMgr *scheduler.TaskManager
}

// RegisterRoutes 注册路由
func (api *TaskAPI) RegisterRoutes(r *gin.RouterGroup) {
    r.GET("/tasks", api.ListTasks)
    r.POST("/tasks", api.CreateTask)
    r.GET("/tasks/:id", api.GetTask)
    r.PUT("/tasks/:id", api.UpdateTask)
    r.DELETE("/tasks/:id", api.DeleteTask)
    r.POST("/tasks/:id/enable", api.EnableTask)
    r.POST("/tasks/:id/disable", api.DisableTask)
    r.POST("/tasks/:id/trigger", api.TriggerTask)
    r.GET("/tasks/:id/executions", api.GetTaskExecutions)
    r.GET("/tasks/:id/next-run", api.GetNextRunTime)
}

// ListTasks 任务列表
// @Summary 获取任务列表
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(20)
// @Param status query int false "状态"
// @Param keyword query string false "关键词"
// @Success 200 {object} Response
// @Router /api/v1/tasks [get]
func (api *TaskAPI) ListTasks(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    status, _ := strconv.Atoi(c.Query("status"))
    keyword := c.Query("keyword")

    req := &ListTasksRequest{
        Page:     page,
        PageSize: pageSize,
        Status:   status,
        Keyword:  keyword,
    }

    tasks, total, err := api.taskMgr.ListTasks(c.Request.Context(), req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }

    c.JSON(http.StatusOK, PageResponse(tasks, total, page, pageSize))
}

// CreateTask 创建任务
// @Summary 创建任务
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param body body CreateTaskRequest true "任务信息"
// @Success 200 {object} Response
// @Router /api/v1/tasks [post]
func (api *TaskAPI) CreateTask(c *gin.Context) {
    var req CreateTaskRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }

    task, err := api.taskMgr.CreateTask(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }

    c.JSON(http.StatusOK, SuccessResponse(task))
}

// TriggerTask 手动触发任务
// @Summary 手动触发任务
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param id path string true "任务ID"
// @Success 200 {object} Response
// @Router /api/v1/tasks/{id}/trigger [post]
func (api *TaskAPI) TriggerTask(c *gin.Context) {
    taskID := c.Param("id")

    var req struct {
        Params map[string]string `json:"params"`
    }
    c.ShouldBindJSON(&req)

    result, err := api.taskMgr.TriggerTask(c.Request.Context(), taskID, req.Params)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }

    c.JSON(http.StatusOK, SuccessResponse(result))
}

// GetNextRunTime 获取下次执行时间
// @Summary 获取任务下次执行时间
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param id path string true "任务ID"
// @Success 200 {object} Response
// @Router /api/v1/tasks/{id}/next-run [get]
func (api *TaskAPI) GetNextRunTime(c *gin.Context) {
    taskID := c.Param("id")

    nextRun, err := api.taskMgr.GetNextRunTime(taskID)
    if err != nil {
        c.JSON(http.StatusNotFound, ErrorResponse(err))
        return
    }

    c.JSON(http.StatusOK, SuccessResponse(gin.H{
        "task_id":     taskID,
        "next_run_time": nextRun,
    }))
}
```

---

## 7. 前端实现

### 7.1 技术栈

```json
{
  "framework": "Vue 3.4+",
  "language": "TypeScript 5.3+",
  "build": "Vite 5.0+",
  "ui": "Element Plus 2.5+",
  "state": "Pinia 2.1+",
  "router": "Vue Router 4.2+",
  "http": "Axios 1.6+",
  "websocket": "原生 WebSocket",
  "charts": "ECharts 5.5+",
  "i18n": "Vue I18n 9.8+",
  "utils": "Lodash-es, Day.js"
}
```

### 7.2 项目配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: { '@': resolve(__dirname, 'src') },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': { target: 'http://localhost:8080', changeOrigin: true },
      '/ws': { target: 'ws://localhost:8080', ws: true },
    },
  },
  build: {
    target: 'es2015',
    rollupOptions: {
      output: {
        manualChunks: {
          'element-plus': ['element-plus'],
          'echarts': ['echarts'],
        },
      },
    },
  },
})
```

### 7.3 请求封装

```typescript
// web/src/utils/request.ts
import axios, { AxiosInstance, AxiosResponse } from 'axios'
import { ElMessage } from 'element-plus'

interface ApiResponse<T = any> {
  code: number
  data: T
  message: string
}

const service: AxiosInstance = axios.create({
  baseURL: '/api/v1',
  timeout: 30000,
})

service.interceptors.response.use(
  (response: AxiosResponse<ApiResponse>) => {
    const { code, data, message } = response.data
    if (code === 0) return data
    ElMessage.error(message || '请求失败')
    return Promise.reject(new Error(message))
  },
  (error) => {
    ElMessage.error(error.message || '网络连接失败')
    return Promise.reject(error)
  }
)

export const request = {
  get<T>(url: string, config?: any) {
    return service.get<T>(url, config)
  },
  post<T>(url: string, data?: any) {
    return service.post<T>(url, data)
  },
  put<T>(url: string, data?: any) {
    return service.put<T>(url, data)
  },
  delete<T>(url: string) {
    return service.delete<T>(url)
  },
}
```

### 7.4 任务 API

```typescript
// web/src/api/task.ts
import { request } from '@/utils/request'

export function getTaskList(params: any) {
  return request.get<TaskList>('/tasks', { params })
}

export function createTask(data: any) {
  return request.post<Task>('/tasks', data)
}

export function updateTask(id: string, data: any) {
  return request.put<Task>(`/tasks/${id}`, data)
}

export function deleteTask(id: string) {
  return request.delete(`/tasks/${id}`)
}

export function enableTask(id: string) {
  return request.post(`/tasks/${id}/enable`)
}

export function disableTask(id: string) {
  return request.post(`/tasks/${id}/disable`)
}

export function triggerTask(id: string, params?: Record<string, string>) {
  return request.post(`/tasks/${id}/trigger`, { params })
}

export function parseCronExpr(expr: string) {
  return request.get<{ next_executions: string[] }>('/tasks/cron/parse', {
    params: { expr },
  })
}

export function getExecutionList(params: any) {
  return request.get<ExecutionList>('/executions', { params })
}

export function getExecutionLogs(id: string) {
  return request.get<{ output: string; error: string }>(`/executions/${id}/logs`)
}

export function getExecutionStats(taskId: string, dateRange: string) {
  return request.get('/executions/stats', { params: { task_id: taskId, date_range: dateRange } })
}
```

### 7.5 Pinia Store

```typescript
// web/src/stores/task.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { getTaskList, enableTask, disableTask, triggerTask } from '@/api/task'

export const useTaskStore = defineStore('task', () => {
  const tasks = ref<Task[]>([])
  const loading = ref(false)
  const total = ref(0)

  const enabledTasks = computed(() => tasks.value.filter((t) => t.status === 1))

  async function fetchTasks(params: any) {
    loading.value = true
    try {
      const data = await getTaskList(params)
      tasks.value = data.items || []
      total.value = data.total || 0
    } finally {
      loading.value = false
    }
  }

  async function toggleTaskStatus(task: Task) {
    const action = task.status === 1 ? disableTask : enableTask
    await action(task.id)
    task.status = task.status === 1 ? 0 : 1
  }

  async function triggerTaskNow(task: Task) {
    const { execution_id } = await triggerTask(task.id)
    return execution_id
  }

  return {
    tasks,
    loading,
    total,
    enabledTasks,
    fetchTasks,
    toggleTaskStatus,
    triggerTaskNow,
  }
})
```

### 7.6 Cron 编辑器组件

```vue
<!-- web/src/components/task/CronEditor.vue -->
<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { ElMessage } from 'element-plus'
import { parseCronExpr } from '@/api/task'

interface Props {
  modelValue: string
  disabled?: boolean
}

interface Emits {
  (e: 'update:modelValue', value: string): void
}

const props = defineProps<Props>()
const emit = defineEmits<Emits>()

const localValue = computed({
  get: () => props.modelValue,
  set: (val) => emit('update:modelValue', val),
})

const presets = [
  { label: '每分钟', value: '* * * * *' },
  { label: '每小时', value: '0 * * * *' },
  { label: '每天凌晨', value: '0 0 * * *' },
  { label: '每5分钟', value: '*/5 * * * *' },
  { label: '每30分钟', value: '0,30 * * * *' },
]

const nextExecutions = ref<string[]>([])
const loading = ref(false)

async function previewNext() {
  if (!localValue.value) return
  loading.value = true
  try {
    const data = await parseCronExpr(localValue.value)
    nextExecutions.value = data.next_executions
  } catch {
    ElMessage.error('Cron 表达式无效')
  } finally {
    loading.value = false
  }
}

watch(localValue, previewNext, { immediate: true })
</script>

<template>
  <div class="cron-editor">
    <div class="presets">
      <span
        v-for="preset in presets"
        :key="preset.value"
        class="preset"
        :class="{ active: localValue === preset.value }"
        @click="!disabled && (localValue = preset.value)"
      >
        {{ preset.label }}
      </span>
    </div>
    <el-input v-model="localValue" :disabled="disabled" placeholder="0 0 * * *" />
    <div v-if="nextExecutions.length" class="next-runs">
      <span>下次执行:</span>
      <span v-for="(time, i) in nextExecutions.slice(0, 5)" :key="i">
        {{ time }}
      </span>
    </div>
  </div>
</template>
```

### 7.7 任务列表页面

```vue
<!-- web/src/views/task/List.vue -->
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessageBox } from 'element-plus'
import { useTaskStore } from '@/stores/task'
import { useWebSocket } from '@/composables/useWebSocket'

const router = useRouter()
const taskStore = useTaskStore()
const { connect, disconnect, onMessage } = useWebSocket()

const queryParams = ref({ page: 1, page_size: 20, status: null, keyword: '' })
const selectedIds = ref<string[]>([])

onMounted(() => {
  connect('/ws/tasks')
  onMessage((data) => {
    if (data.type === 'task_status_changed') taskStore.fetchTasks(queryParams.value)
  })
  fetchTasks()
})
onUnmounted(() => disconnect())

async function fetchTasks() {
  await taskStore.fetchTasks(queryParams.value)
}

function handleCreate() {
  router.push('/tasks/create')
}

function handleEdit(task: Task) {
  router.push(`/tasks/${task.id}/edit`)
}

async function handleDelete(task: Task) {
  await ElMessageBox.confirm(`确定删除 "${task.name}"?`, '提示', { type: 'warning' })
  await deleteTask(task.id)
  ElMessage.success('删除成功')
  fetchTasks()
}
</script>

<template>
  <div class="task-list">
    <el-form :model="queryParams" inline>
      <el-form-item label="状态">
        <el-select v-model="queryParams.status" clearable>
          <el-option label="全部" :value="null" />
          <el-option label="运行中" :value="1" />
          <el-option label="已停止" :value="0" />
        </el-select>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="fetchTasks">查询</el-button>
      </el-form-item>
    </el-form>

    <div class="toolbar">
      <el-button type="primary" @click="handleCreate">新建任务</el-button>
    </div>

    <el-table v-loading="taskStore.loading" :data="taskStore.tasks">
      <el-table-column type="selection" width="55" />
      <el-table-column prop="name" label="任务名称" />
      <el-table-column prop="cron_expr" label="Cron" />
      <el-table-column prop="status" label="状态">
        <template #default="{ row }">
          <el-tag :type="row.status === 1 ? 'success' : 'info'">
            {{ row.status === 1 ? '运行中' : '已停止' }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column label="操作">
        <template #default="{ row }">
          <el-button link @click="handleEdit(row)">编辑</el-button>
          <el-button link type="primary" @click="taskStore.toggleTaskStatus(row)">
            {{ row.status === 1 ? '停止' : '启用' }}
          </el-button>
          <el-button link type="danger" @click="handleDelete(row)">删除</el-button>
        </template>
      </el-table-column>
    </el-table>

    <el-pagination
      v-model:current-page="queryParams.page"
      :total="taskStore.total"
      @change="fetchTasks"
    />
  </div>
</template>
```

### 7.8 WebSocket 钩子

```typescript
// web/src/composables/useWebSocket.ts
import { ref, onUnmounted } from 'vue'

export function useWebSocket() {
  const ws = ref<WebSocket | null>(null)
  const connected = ref(false)
  const handlers = new Map<string, (data: any) => void>()

  function connect(url: string) {
    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:'
    ws.value = new WebSocket(`${protocol}//${location.host}${url}`)

    ws.value.onopen = () => { connected.value = true }
    ws.value.onclose = () => {
      connected.value = false
      setTimeout(() => connect(url), 5000) // 自动重连
    }
    ws.value.onmessage = (event) => {
      const data = JSON.parse(event.data)
      handlers.get(data.type)?.(data)
    }
  }

  function disconnect() {
    ws.value?.close()
  }

  function onMessage(type: string, handler: Function) {
    handlers.set(type, handler as any)
  }

  onUnmounted(() => disconnect())

  return { connected, connect, disconnect, onMessage }
}
```

### 7.9 路由配置

```typescript
// web/src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  { path: '/', redirect: '/dashboard' },
  { path: '/dashboard', component: () => import('@/views/dashboard/Index.vue') },
  { path: '/tasks', component: () => import('@/views/task/List.vue') },
  { path: '/tasks/create', component: () => import('@/views/task/Form.vue') },
  { path: '/tasks/:id/edit', component: () => import('@/views/task/Form.vue') },
  { path: '/executions', component: () => import('@/views/task/Execution.vue') },
  { path: '/groups', component: () => import('@/views/group/List.vue') },
]

export default createRouter({
  history: createWebHistory(),
  routes,
})
```

### 7.10 前端页面清单

| 页面 | 路径 | 组件 | 说明 |
|-----|------|-----|------|
| 概览仪表盘 | /dashboard | dashboard/Index.vue | 关键指标、图表 |
| 任务列表 | /tasks | task/List.vue | 任务CRUD、启停控制 |
| 任务表单 | /tasks/create | task/Form.vue | 创建/编辑任务 |
| 任务详情 | /tasks/:id | task/Detail.vue | 任务详情、执行历史 |
| 执行监控 | /executions | task/Execution.vue | 执行记录、日志查看 |
| 分组管理 | /groups | group/List.vue | 分组CRUD、主机管理 |
| 系统设置 | /settings | settings/Index.vue | 系统配置、用户管理 |

---

## 8. 部署方案

### 7.1 服务端部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  quicflow-server:
    image: quicflow/server:latest
    container_name: quicflow-server
    ports:
      - "8443:8443"   # QUIC 端口
      - "8080:8080"   # HTTP API 端口
    environment:
      - QUICFLOW_SERVER_ADDR=0.0.0.0:8443
      - QUICFLOW_HTTP_ADDR=0.0.0.0:8080
      - QUICFLOW_MYSQL_DSN=root:password@tcp(mysql:3306)/quicflow
      - QUICFLOW_LOG_LEVEL=info
    depends_on:
      - mysql
    volumes:
      - ./config:/app/config
    restart: unless-stopped

  mysql:
    image: mysql:8.0
    container_name: quicflow-mysql
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=quicflow
    volumes:
      - mysql-data:/var/lib/mysql
      - ./scripts/migration.sql:/docker-entrypoint-initdb.d/migration.sql
    restart: unless-stopped

volumes:
  mysql-data:
```

### 7.2 客户端部署

```bash
#!/bin/bash
# 安装客户端

# 下载
wget https://github.com/quicflow/quicflow/releases/latest/download/quicflow-client-linux-amd64.tar.gz

# 解压
tar -xzf quicflow-client-linux-amd64.tar.gz

# 配置
cat > /etc/quicflow/client.yaml <<EOF
server:
  addr: "quicflow-server:8443"
  tls:
    skip_verify: false
    ca_file: "/etc/quicflow/certs/ca.pem"

client:
  id: "client-$(hostname)"
  group_id: "default"
  storage_path: "/var/lib/quicflow/tasks"
  retention_days: 7

logging:
  level: "info"
  file: "/var/log/quicflow/client.log"
EOF

# 安装服务
cp quicflow-client /usr/local/bin/
cp quicflow-client.service /etc/systemd/system/

# 启动
systemctl daemon-reload
systemctl enable quicflow-client
systemctl start quicflow-client
```

```ini
# quicflow-client.service
[Unit]
Description=QuicFlow Client
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/quicflow-client -config /etc/quicflow/client.yaml
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### 7.3 配置说明

```yaml
# 服务端配置 server.yaml
server:
  # QUIC 监听地址
  quic_addr: "0.0.0.0:8443"

  # HTTP API 监听地址
  http_addr: "0.0.0.0:8080"

  # TLS 证书
  tls:
    cert_file: "/etc/quicflow/certs/server.pem"
    key_file: "/etc/quicflow/certs/server-key.pem"

database:
  # MySQL 连接
  dsn: "root:password@tcp(127.0.0.1:3306)/quicflow?charset=utf8mb4&parseTime=True"

  # 连接池配置
  max_open_conns: 100
  max_idle_conns: 10

scheduler:
  # Cron 调度器配置
  with_seconds: true       # 启用秒级调度

  # 任务分发配置
  dispatch_timeout: 30s    # 分发超时
  dispatch_concurrency: 100 # 并发分发数

storage:
  # 执行记录保留天数
  execution_retention_days: 30

  # 日志保留天数
  log_retention_days: 7

logging:
  level: "info"
  file: "/var/log/quicflow/server.log"
  max_size: 100        # MB
  max_backups: 10
  max_age: 30          # days
```

---

## 8. 监控与运维

### 8.1 Prometheus 指标

```go
// pkg/metrics/scheduler.go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // 调度器指标
    ScheduledTasksTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "quicflow_scheduled_tasks_total",
            Help: "Total number of tasks scheduled",
        },
        []string{"task_id", "status"},
    )

    TaskExecutionDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "quicflow_task_execution_duration_seconds",
            Help:    "Task execution duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"task_id", "executor_type"},
    )

    TaskExecutionResult = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "quicflow_task_execution_result_total",
            Help: "Total number of task executions by result",
        },
        []string{"task_id", "result"}, // success, failure, timeout
    )

    ClientConnections = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "quicflow_client_connections",
            Help: "Number of connected clients",
        },
        []string{"group_id"},
    )

    ConfigSyncDuration = promauto.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "quicflow_config_sync_duration_seconds",
            Help:    "Config sync duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
    )
)
```

### 8.2 健康检查

```go
// pkg/api/health.go
package api

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

// HealthAPI 健康检查 API
type HealthAPI struct {
    cron   *scheduler.CronScheduler
    db     *gorm.DB
    quic   *quic.Server
}

// RegisterRoutes 注册路由
func (api *HealthAPI) RegisterRoutes(r *gin.RouterGroup) {
    r.GET("/health", api.HealthCheck)
    r.GET("/health/ready", api.ReadinessCheck)
    r.GET("/health/live", api.LivenessCheck)
}

// HealthCheck 健康检查
func (api *HealthAPI) HealthCheck(c *gin.Context) {
    health := gin.H{
        "status": "ok",
        "components": gin.H{
            "cron": api.checkCron(),
            "db":    api.checkDB(),
            "quic":  api.checkQUIC(),
        },
    }

    // 检查各组件状态
    allHealthy := true
    for k, v := range health["components"].(gin.H) {
        if v != "ok" {
            allHealthy = false
            health["components"].(gin.H)[k] = v
        }
    }

    if !allHealthy {
        c.JSON(http.StatusServiceUnavailable, health)
        return
    }

    c.JSON(http.StatusOK, health)
}

func (api *HealthAPI) checkCron() string {
    stats := api.cron.GetStats()
    if stats["running"] == true {
        return "ok"
    }
    return "stopped"
}

func (api *HealthAPI) checkDB() string {
    if err := api.db.DB().Ping(); err != nil {
        return "error: " + err.Error()
    }
    return "ok"
}

func (api *HealthAPI) checkQUIC() string {
    if api.quic != nil {
        return "ok"
    }
    return "not initialized"
}
```

---

## 9. 开发计划

### 9.1 里程碑

| 阶段 | 内容 | 交付物 |
|-----|------|-------|
| Phase 1 | 基础设施 | 数据库表、Protobuf 协议 |
| Phase 2 | 服务端调度 | Cron 调度器、任务管理器 |
| Phase 3 | 客户端引擎 | 任务引擎、执行器池 |
| Phase 4 | 本地存储 | 本地存储、同步管理器 |
| Phase 5 | API 接口 | REST API、前端页面 |
| Phase 6 | 测试联调 | 集成测试、性能测试 |
| Phase 7 | 部署上线 | Docker 镜像、部署文档 |

### 9.2 关键依赖

```go
// go.mod
module github.com/quic-flow/quic-flow

go 1.21

require (
    github.com/robfig/cron/v3 v3.0.1
    github.com/gin-gonic/gin v1.9.1
    github.com/quic-go/quic-go v0.40.0
    gorm.io/gorm v1.25.5
    gorm.io/driver/mysql v1.5.2
    go.uber.org/zap v1.26.0
    github.com/prometheus/client_golang v1.17.0
    google.golang.org/protobuf v1.31.0
)
```

---

## 10. 附录

### 10.1 Cron 表达式示例

| 表达式 | 说明 |
|-------|------|
| `0 * * * * *` | 每分钟的第 0 秒 |
| `0 30 * * * *` | 每小时的第 30 分 |
| `0 30 2 * * *` | 每天凌晨 2:30 |
| `0 0 */2 * * *` | 每 2 小时 |
| `0 0 0 * * 1` | 每周一午夜 |
| `0 0 0 1 * *` | 每月 1 号午夜 |
| `@daily` | 每天午夜 |
| `@hourly` | 每小时 |
| `@every 1h30m` | 每 1 小时 30 分钟 |

### 10.2 错误码定义

| 错误码 | 说明 |
|-------|------|
| 1001 | 任务不存在 |
| 1002 | 任务名称重复 |
| 1003 | Cron 表达式无效 |
| 1004 | 执行器类型不支持 |
| 1005 | 任务正在执行中 |
| 2001 | 客户端未连接 |
| 2002 | 分组不存在 |
| 2003 | 配置推送失败 |
| 3001 | 执行超时 |
| 3002 | 执行失败 |
| 3003 | 执行被取消 |

---

**文档结束**
