---
description: 根据用户需求为当前功能生成自定义检查清单
---

## 📋 命令用途

**生成需求质量验证清单**

---

## 检查清单的目的："需求的单元测试"

**关键概念**：检查清单是**需求编写的单元测试** - 它们验证给定领域中需求的质量、清晰度和完整性。

**不是用于验证/测试**：
- ❌ 不是"验证按钮点击是否正确"
- ❌ 不是"测试错误处理是否工作"
- ❌ 不是"确认 API 返回 200"
- ❌ 不是检查代码/实现是否匹配规范

**用于需求质量验证**：
- ✅ "是否为所有卡片类型定义了视觉层次需求？"（完整性）
- ✅ "'突出显示'是否用具体的大小/位置量化？"（清晰度）
- ✅ "所有交互元素的悬停状态需求是否一致？"（一致性）
- ✅ "是否定义了键盘导航的可访问性需求？"（覆盖率）
- ✅ "规范是否定义了徽标图片加载失败时的情况？"（边界情况）

**比喻**：如果您的规范是用英语编写的代码，检查清单就是它的单元测试套件。您正在测试需求是否编写良好、完整、明确并准备好实现 - 而不是实现是否有效。

## 用户输入

```text
$ARGUMENTS
```

在继续之前，您**必须**考虑用户输入（如果不为空）。

## 执行步骤

1. **设置**：从仓库根目录运行 `.specify/scripts/bash/check-prerequisites.sh --json` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。
   - 所有文件路径必须是绝对路径。
   - 对于参数中的单引号（如"I'm Groot"），使用转义语法：例如 'I'\''m Groot'（或者如果可能使用双引号："I'm Groot"）。

2. **澄清意图（动态）**：从用户的措辞 + 从 spec/plan/tasks 提取的信号中派生最多三个初始上下文澄清问题。它们必须：
   - 从用户的措辞 + 从 spec/plan/tasks 提取的信号生成
   - 仅询问实质性改变检查清单内容的信息
   - 如果在 `$ARGUMENTS` 中已经明确则单独跳过
   - 优先考虑精确性而非广度

   生成算法：
   1. 提取信号：功能领域关键词（例如身份验证、延迟、用户体验、API）、风险指标（"关键"、"必须"、"合规"）、利益相关者提示（"QA"、"审查"、"安全团队"）和明确的交付成果（"无障碍"、"回滚"、"契约"）。
   2. 将信号聚类到候选关注领域（最多 4 个），按相关性排名。
   3. 识别可能的受众和时机（作者、审阅者、QA、发布），如果不明确。
   4. 检测缺失的维度：范围广度、深度/严格性、风险重点、排除边界、可衡量的验收标准。
   5. 从这些原型中选择问题进行表述：
      - 范围细化（例如"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？"）
      - 风险优先级（例如"这些潜在风险领域中哪些应该接受强制门控检查？"）
      - 深度校准（例如"这是轻量级的提交前健全性列表还是正式的发布门控？"）
      - 受众框架（例如"这将仅由作者使用还是在 PR 审查期间由同行使用？"）
      - 边界排除（例如"我们应该在本轮中明确排除性能调优项目吗？"）
      - 场景类差距（例如"未检测到恢复流程 - 回滚/部分失败路径是否在范围内？"）

   问题格式规则：
   - 如果呈现选项，生成包含列的紧凑表：选项 | 候选 | 为什么重要
   - 最多限制 A–E 选项；如果自由形式答案更清晰则省略表
   - 永远不要要求用户重述他们已经说过的内容
   - 如果用户的请求已经具体（例如"性能检查清单"），跳过模糊的问题

3. **等待用户响应**（如果提出了问题）：
   - 解析答案（例如"A"、"选项 B"、"自定义：..."）
   - 如果用户说"跳过"或"默认"，使用从规范/计划推断的合理默认值
   - 不要重复提问

4. **加载相关上下文**：
   - 读取 `spec.md`：需求、用户故事、成功标准
   - 读取 `plan.md`（如果存在）：技术上下文、架构、组件
   - 读取 `tasks.md`（如果存在）：实现细节、阶段
   - 读取 `.specify/memory/constitution.md`：强制原则、质量标准

5. **检查清单生成**：
   - 创建文件：`FEATURE_DIR/checklists/[检查清单名称].md`
   - 使用此结构：

     ```markdown
     # [检查清单名称]：[功能名称]

     **目的**：[从用户意图派生的 1-2 句话目的]
     **创建日期**：[日期]
     **功能**：[链接到 spec.md]
     **受众**：[作者/审阅者/QA/团队]

     ## [类别 1 名称]

     - [ ] [检查项 1 - 作为问题表述，针对需求质量]
     - [ ] [检查项 2]
     - [ ] [检查项 3]

     ## [类别 2 名称]

     - [ ] [检查项 4]
     - [ ] [检查项 5]

     ## [类别 N 名称]

     - [ ] [检查项 N]

     ## 备注

     [任何上下文、例外或指导]
     ```

6. **检查清单内容规则**：

   **每个检查项必须**：
   - 是一个问题（"是否..."、"做..."），而不是陈述
   - 测试需求质量，而不是实现验证
   - 具体且可操作（避免"考虑..."、"思考关于..."）
   - 可以用"是"或"否"回答（或"N/A"，如果适用）
   - 引用规范/计划中的具体元素，如果相关

   **好的检查项示例**：
   - ✅ "是否为每个用户角色定义了明确的权限边界？"
   - ✅ "每个错误场景是否指定了具体的用户反馈？"
   - ✅ "性能目标是否以可衡量的指标量化（例如 <100ms）？"
   - ✅ "所有 API 端点是否记录了预期的错误代码？"

   **不好的检查项示例**：
   - ❌ "考虑边界情况"（太模糊）
   - ❌ "验证登录工作"（这是测试，不是需求检查）
   - ❌ "代码遵循最佳实践"（这是代码审查，不是规范验证）
   - ❌ "测试通过"（这是验证，不是需求质量）

7. **类别生成**：
   - 根据功能领域和用户意图创建 3-7 个类别
   - 常见类别（仅在相关时使用）：
     - 功能完整性
     - 用户体验清晰度
     - 错误和边界情况
     - 性能和可扩展性
     - 安全和隐私
     - 可访问性
     - 数据完整性
     - 集成和依赖关系
   - 每个类别 3-8 个检查项（避免过长的列表）

8. **报告完成**：
   - 输出：`FEATURE_DIR/checklists/[检查清单名称].md`
   - 摘要：总检查项数、类别数
   - 下一步：如何使用检查清单验证规范/计划

## 关键规则

- **质量，而不是验证**：检查清单测试需求质量，而不是实现正确性
- **具体且可操作**：每个项目都必须清晰且可检查
- **上下文感知**：根据功能领域、风险和受众定制
- **适当的大小**：足够全面以有用，但不会压倒性（20-40 项）
- **链接到规范**：检查项应该引用规范/计划中的具体元素

## 示例用途

**用户请求**："为登录功能创建安全检查清单"

**生成的检查清单应该验证**：
- ✅ 规范是否定义了密码复杂性要求？
- ✅ 身份验证失败场景是否有明确的用户反馈？
- ✅ 会话管理生命周期是否已记录？
- ✅ 速率限制规则是否已指定？

**而不是**：
- ❌ 验证密码哈希是否正常工作（这是测试）
- ❌ 确认 SQL 注入得到防御（这是安全审查）
